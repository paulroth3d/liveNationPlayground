<?xml version='1.0' encoding='UTF-8'?>
<project name="SFDC Ant" basedir="." default="setup"
	xmlns:sf="http://com.salesforce"
	xmlns:mm="http://com.modelmetrics"
>
	<!-- @TODO
	- make target to provide/validate translations for an entire set of static
	resources or just those from a package list.
	- currently if new report folders are added, these are not supported in
	the current deployment process. (Report folders are based on -meta.xml files
	git does not track folders being created, only files. and the current project
	does not deploy -meta.xml files outright, only the files that the -meta shadow.
	- Update the ant-jar with the latest -
	https://login.salesforce.com/dwnld/SfdcAnt/salesforce_ant_34.0.zip,
	but do so to allow the ant jar to be templated / therefore updatable to whichever
	without showing as a change / conflicting with other projects.
	- links should NOT open in a new tab in AutoDocs
	- profile names with html escapable characters break in links on profile report.
	- links should NOT open in a new tab in AutoDocs
	- profile names with html escapable characters break in links on profile report.
	-->
	
	<!-- expected version of the build.properties template.
		If the current build.properties does not match, the user is asked
		to re-setup the project (using the latest build.properties tmplate -->
	<property name="build.prop.format.expected" value="101" />
	
	<property name="antlib" value="antlib" />
	
	<!--
	Defines task extensions for additional functionality in the ant scripts
	antcontrib: provides additional logic and file handling capabilities
	salesforce: provides salesforce integration
	
	notice the URI matching the xmlns defined above
	-->
	
	<taskdef resource="net/sf/antcontrib/antlib.xml">
		<classpath>
			<pathelement location="${antlib}/ant-contrib-1.0b3.jar" />
		</classpath>
	</taskdef>
	
	<taskdef resource="com/salesforce/sforce_ant.properties" uri="http://com.salesforce">
		<classpath>
			<pathelement location="${antlib}/ant-salesforce.jar" />
		</classpath>
	</taskdef>
	
	<taskdef resource="com/modelmetrics/Ant_Lib.properties" uri="http://com.modelmetrics">
		<classpath>
			<pathelement location="${antlib}/ant-salesforce-mm.jar" />
		</classpath>
	</taskdef>
	
	<!-- target for developers looking to better understand the mm tasks -->
	<target name="infoMM_Tasks">
		<mm:ListTasks />
	</target>
	
	<!-- prefix for environment variables -->
	<property environment="env" />
	
	<!-- description of the project. used when calling ant -p -->
	<description>
Run the following for more information
ant help
	</description>
	
	<target name="help" description="Shows help information">
		<echo><![CDATA[
#	#	#	#	#	#	#
   _____ ______ _____   _____            _   _ _______ 
  / ____|  ____|  __ \ / ____|     /\   | \ | |__   __|
 | (___ | |__  | |  | | |         /  \  |  \| |  | |   
  \___ \|  __| | |  | | |        / /\ \ | . ` |  | |   
  ____) | |    | |__| | |____   / ____ \| |\  |  | |   
 |_____/|_|    |_____/ \_____| /_/    \_\_| \_|  |_|   


Used as the central builder for working with iOS and force.com.

### PREREQUISITE: requires ant installed
	
For general information and a list of current information run:
$> ant

or
$> ant help

Run the following command for all public targets
ant -p

*** NOTE: ANT IS CASE SENSITIVE *** <br />
*** A list of all targets is below ***

	ant test		   - Tests your setup and credentials
	ant help           - Minimal help
	ant -p             - lists all targets

	ant status         - describes the current status of the project.
	ant settings       - works with settings like test deploys.

	ant new            - Creates files based on templates

	ant list           - High level target to list out metadata
	ant packageList    - Works with package lists
	ant modifyPackage  - High level target working with packages
	
	ant retrieveFiles  - High level target for retrieving
	ant deployFiles    - High level target for deploying
	ant retrieveDeploy - High level target (includes both retrieveFiles / deployFiles)
	
	ant destroy        - High level target for destroying metadata
	
	ant git            - High level target using git on the source code.
	ant auto           - AutoDeployment related Tasks

	ant doc            - Generates Documentation for all apex classes retrieved.
	
]]></echo>
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	Properties
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	<!-- default values not meant to change -->
	<property name="meta_suffix" value="-meta.xml" />
	<property name="tab" value="    " />
	<property name="abort.user" value="Halting due to user request" />
	<property name="abort.stop" value="Unable to continue" />
	<property name="package.file" value="package.xml" />
	<property name="tmp.dir" value="tmp" />
	<property name="tmp.path" value="${tmp.dir}" />
	<property name="tmp.filename" value="tmp.tmp" />
	<property name="tmp.file.path" value="${tmp.dir}/${tmp.filename}" />
	<property name="tmp2.filename" value="tmp2.tmp" />
	<property name="tmp2.file.path" value="${tmp.dir}/${tmp2.filename}" />
	<property name="tmp.deploy.dir" value="testDeploy" />
	<property name="tmp.deploy.path" value="${tmp.dir}/${tmp.deploy.dir}" />
	<property name="tmp.deploy.output.file" value="deployOut.txt" />
	<property name="tmp.deploy.output.path" value="${tmp.dir}/${tmp.deploy.output.path}" />
	<property name="tmp.retrieve.dir" value="testRetrieve" />
	<property name="tmp.retrieve.path" value="${tmp.dir}/${tmp.retrieve.dir}" />
	<property name="n" value="${line.separator}" />
	<property name="enterContinue" value="(Press enter to continue)" />
	
	<!-- FIX: allow jenkins to send a blank autodeploy (through a parameterization)
		and still not affect the autodeploy sequence. -->
	<if>
		<equals arg1="${last.autodeploy}" arg2="" />
		<then>
			<var name="last.autodeploy" unset="true" />
		</then>
	</if>
	
	<!-- properties from property files -->
	<property file="build.environment" />
	<property file="build.properties" />
	<property file="build.credentials" />
	<property file="build.autodeploy" />
	
	<property name="resources.dir" value="resources" />
	<property name="resources.path" value="${resources.dir}" />
	<property name="environment.settings.file" value="environment.settings" />
	<property name="environment.settings.path" value="${resources.path}/${environment.settings.file}" />
	
	<property file="${environment.settings.path}" />
	<property name="default.environment" value="env1" />
	
	<!-- default values for those not set in the two property files -->
	<property name="SFDC_VERSION" value="26.0" />
	<property name='buildPrefix' value='' />
	<property name="isTestDeploy" value="true" />
	<property name="force.environment" value="env1" />
	
	<!-- names of files -->
	<property name="docs.dir" value="docs" />
	
	<property name="force.dir" value="force" />
	<property name="force.path" value="${force.dir}" />
	<property name="doxygen.config.file" value="doxygen.config" />
	<property name="doxygen.config.path" value="${force.path}/${doxygen.config.file}" />
	<property name="src.dir" value="src" />
	<property name="src.path" value="${force.path}/${src.dir}" />
	<property name="force.package.file" value="package.xml" />
	<property name="force.package.path" value="${src.path}/${force.package.file}" />
	<property name="force.destructive.file" value="destructiveChanges.xml" />
	<property name="staticresources.dir" value="staticresources" />
	<property name="staticresources.path" value="${src.path}/${staticresources.dir}" />
	<property name="classes.dir" value="classes"/>
	<property name="classes.path" value="${src.path}/${classes.dir}" />
	<property name="objects.dir" value="objects" />
	<property name="objects.path" value="${src.path}/${objects.dir}" />
	<property name="profiles.dir" value="profiles" />
	<property name="profiles.path" value="${src.path}/${profiles.dir}" />
	<property name="permissionSets.dir" value="permissionsets" />
	<property name="permissionSets.path" value="${src.path}/${permissionSets.dir}" />
	<property name="pages.dir" value="pages" />
	<property name="pages.path" value="${src.path}/${pages.dir}" />
	<property name="lastRefreshPackage.file" value="lastRefresh.xml" />
	<property name="lastRefreshPackage.path" value="${src.path}/${lastRefreshPackage.file}" />
	
	<property name="destructiveChangesPre.file" value="destructiveChangesPre.xml" />
	<property name="destructiveChangesPre.path" value="${src.path}/${destructiveChangesPre.file}" />
	<property name="destructiveChangesPost.file" value="destructiveChangesPost.xml" />
	<property name="destructiveChangesPost.path" value="${src.path}/${destructiveChangesPost.file}" />
	
	<property name="deploy.dir" value="deploy" />
	<property name="deploy.path" value="${deploy.dir}" />
	<property name="deploy.package.path" value="${deploy.path}/${force.package.file}" />
	<property name="deploy.destructive.path" value="${deploy.path}/${force.destructive.file}" />
	<property name="deploy.staticresource.type" value="StaticResource" />
	<property name="autodeploy.autoLatestCommit" value="false" />
	
	<property name="packageLists.dir" value="packageLists" />
	<property name="packageLists.path" value="${packageLists.dir}" />
	<property name="ignore.file" value="Ignore.txt" />
	<property name="ignore.path" value="${packageLists.dir}/${ignore.file}" />
	<property name="all.packageList.file" value="all.txt" />
	<property name="all.packageList.path" value="${packageLists.path}/${all.packageList.file}" />
	<property name="profile.packageList.file" value="profile.txt" />
	<property name="profile.packageList.path" value="${packageLists.path}/${profile.packageList.file}" />
	<property name="profile.checkout.dir" value="profileCheckout" />
	<property name="profile.checkout.path" value="${tmp.path}/${profile.checkout.dir}" />
	<property name="file.packageList.file" value="file.txt" />
	<property name="file.packageList.path" value="${packageLists.path}/${file.packageList.file}" />
	
	<property name="output.dir" value="output" />
	<property name="output.path" value="${output.dir}" />
	
	<property name="templates.dir" value="templates" />
	<property name="templates.path" value="${templates.dir}" />
	<property name="force.package.template" value="${templates.path}/${force.package.file}" />
	<property name="doxygen.template" value="${templates.path}/${doxygen.config.file}" />
	<property name="build.properties.template" value="${templates.path}/build.properties.template" />
	<property name="build.credentials.template" value="${templates.path}/build.credentials.template" />
	<property name="build.environment.template" value="${templates.path}/build.environment.template" />
	<property name="build.autodeploy.template" value="${templates.path}/build.autodeploy.template" />
	<property name="environment.settings.template" value="${templates.path}/environment.settings.template" />
	<property name="packageLists.template" value="${templates.path}/sample_all.txt" />
	<property name="meta.dir" value="meta" />
	<property name="meta.path" value="${templates.path}/${meta.dir}" />
	
	<property name="reports.dir" value="reports" />
	<property name="reports.path" value="${templates.path}/${reports.dir}" />
	<property name="reportResources.dir" value="reportResources" />
	<property name="reportResources.path" value="${reports.path}/${reportResources.dir}" />
	<property name="reportResources.target.dir" value="_src" />
	<property name="reportResources.target.path" value="${output.path}/${reportResources.target.dir}" />
	<property name="flows.meta" value="flows" />
	<property name="profiles.meta" value="profiles" />
	<property name="objects.meta" value="objects" />
	<property name="workflows.meta" value="workflows" />
	<property name="permissionSet.meta" value="permissionsets" />
	
	<property name="flow.report" value="flowReport.xsl" />
	<property name="flow.result.dir" value="flows" />
	<property name="flow.result.path" value="${output.path}/${flow.result.dir}" />
	
	<property name="matrix.result.dir" value="matrix" />
	<property name="matrix.result.path" value="${output.path}/${matrix.result.dir}" />
	
	<property name="object.report" value="objectReport.xsl" />
	<property name="object.result.dir" value="objects" />
	<property name="object.result.path" value="${output.path}/${object.result.dir}" />
	
	<property name="profile.report" value="profileReport.xsl" />
	<property name="profile.result.dir" value="profiles" />
	<property name="profile.result.path" value="${output.path}/${profile.result.dir}" />
	
	<property name="workflow.report" value="workflowReport.xsl" />
	<property name="workflow.result.dir" value="workflows" />
	<property name="workflow.result.path" value="${output.path}/${workflow.result.dir}" />
	
	<property name="ApexDocumentation.dir" value="ApexDocumentation" />
	<property name="code.result.dir" value="${ApexDocumentation.dir}" />
	<property name="code.result.path" value="${output.path}/${code.result.dir}" />
	<property name="code.index.path" value="${code.result.path}/index.html" />
	<property name="code.index.target" value="${code.result.path}/_index.html" />
	
	<property name="change.result.dir" value="changes" />
	<property name="change.result.path" value="${output.path}/${change.result.dir}" />
	<property name="change.index.target" value="${change.result.path}/index.html" />
	<property name="change.result.file" value="changeReport.txt" />
	<property name="change.result.file.path" value="${change.result.path}/${change.result.file}" />
	
	<property name="diffReport.result.dir" value="diff" />
	<property name="diffReport.result.path" value="${output.path}/${diffReport.result.dir}" />
	<property name="diffReport.index.target" value="${diffReport.result.path}/index.html" />
	<property name="diffReport.output.target" value="${diffReport.result.path}/output.html" />
	<property name="diffReport.header.file" value="readme.txt" />
	<property name="diffReport.header.path" value="${diffReport.result.path}/${diffReport.header.file}" />	
	<property name="diffReport.diff.file" value="diffReport.diff" />
	<property name="diffReport.diff.path" value="${diffReport.result.path}/${diffReport.diff.file}" />
	
	<property name="workbook.report" value="workbook.xsl" />
	<property name="workbook.result.dir" value="workbooks" />
	<property name="workbook.result.path" value="${output.path}/${workbook.result.dir}" />
	
	<property name="xslt.result.path" value="${output.path}/xslt" />
	
	<property name="code.result.dir" value="${ApexDocumentation.dir}" />
	<property name="ApexDocumentation.path" value="${output.path}/${ApexDocumentation.dir}" />
	<property name="code.result.path" value="${ApexDocumentation.path}" />
	<property name="ApexDoc.css.file" value="ApexDoc.css" />
	<property name="ApexDoc.css.path" value="${reports.path}/${ApexDoc.css.file}" />
	<property name="ApexDoc.css.target" value="${ApexDocumentation.path}/${ApexDoc.css.file}" />
	<property name="report.sideNav.template.file" value="sideNav.html" />
	<property name="report.sideNav.template.path" value="${reports.path}/${report.sideNav.template.file}" />
	<property name="report.objectNav.template.file" value="objectNav.html" />
	<property name="report.objectNav.template.path" value="${reports.path}/${report.objectNav.template.file}" />
	<property name="report.profileNav.template.file" value="profileNav.html" />
	<property name="report.profileNav.template.path" value="${reports.path}/${report.profileNav.template.file}" />
	<property name="report.codeNav.template.file" value="codeNav.html" />
	<property name="report.codeNav.template.path" value="${reports.path}/${report.codeNav.template.file}" />
	<property name="report.change.template.file" value="changeNav.html" />
	<property name="report.change.template.path" value="${reports.path}/${report.change.template.file}" />
	<property name="report.flowNav.template.file" value="flowNav.html" />
	<property name="report.flowNav.template.path" value="${reports.path}/${report.flowNav.template.file}" />
	<property name="report.workflowNav.template.file" value="workflowNav.html" />
	<property name="report.workflowNav.template.path" value="${reports.path}/${report.workflowNav.template.file}" />
	<property name="report.workbookNav.template.file" value="workbookNav.html" />
	<property name="report.workbookNav.template.path" value="${reports.path}/${report.workbookNav.template.file}" />
	<property name="report.matrixNav.template.file" value="matrixNav.html" />
	<property name="report.matrixNav.template.path" value="${reports.path}/${report.matrixNav.template.file}" />
	<property name="index.file" value="index.html" />
	<property name="tmp.index.path" value="${tmp.path}/${index.file}" />
	<property name="tmp.section.index.path" value="${tmp.path}/section.index.html" />
	<property name="index.template.path" value="${reports.path}/${index.file}" />
	<property name="index.path" value="${output.path}/${index.file}" />
	
	<property name="deploy.profiles.path" value="${deploy.path}/${profiles.meta}" />
	<property name="tmp.profiles.path" value="${tmp.deploy.path}/${profiles.meta}" />
	
	<property name="DocMetadataTypes" value="CustomObject,Profile,PermissionSet,Layout,Flow,Workflow,ApexClass,ApexPage,ApexTrigger" />
	
	<!-- calculated values -->
	<property name="tmp.deploy.package.path" value="${tmp.deploy.path}/${force.package.file}" />
	
	<tstamp>
		<format property="timestamp.numeric" pattern="yyyyMMdd_hhmmss" />
	</tstamp>
	<tstamp>
		<format property="timestamp.readible" pattern="MM-dd-yyy @ hh:mm:ss" />
	</tstamp>
	
	<mkdir dir="${tmp.path}" />
	<touch file="${tmp.file.path}" />
	<available file="build.properties" type="file" property="isSetup" />
	
	<if>
		<equals arg1="${isCI}" arg2="true" />
		<then>
			<property name="overrideContinue" value="true" />
			<property name="setupContinueA" value="true" />
			<property name="setupCredentials" value="n" />
			<property name="updateIndices" value="n" />
		</then>
	</if>
	
	<!-- set default max poll -->
	<property name="retrieve.maxPoll" value="500" />
	<property name="deploy.maxPoll" value="500" />
	
	<available file="${force.package.path}" type="file" property="force.package.exists" />
	
	<!-- attempt to use the force environment credentials outside of target -->
	<if>
		<equals arg1="${force.environment}" arg2="$${force.environment}" />
		<then>
			<echo><![CDATA[
force.environment was not specified in either build.properties or resources/environment.settings

Adding it in to build.properties.
]]></echo>

			<!-- startup overwrites this file
			<echo file="build.properties" append="true"><![CDATA[
# Environment to refresh and retrieve from.
# If left commented out (# before the line)
# the force.environment defined in resources/environment.settings will be used.
# (This allows for closely tying 
#(Note: the value defined in resources/environment.settings
# will be preferred as it is assumed in synch with the src directory)
force.environment=${default.environment}
]]></echo>-->
			<replaceregexp encoding="UTF-8" file="build.properties"
				match="^\s*#\s*force.environment\s*="
				replace="force.environment="
				flags="img"
			/>
		</then>
		<elseif>
			<equals arg1="${force.environment}" arg2="" />
			<then>
				<var name="force.environment" unset="true" />
				<var name="force.environment" value="${default.environment}" />
			</then>
		</elseif>
	</if>
	<if>
		<equals arg1="${force.retrieve.environment}" arg2="$${force.retrieve.environment}" />
		<then><var name="force.retrieve.environment" unset="true" /></then>
	</if>
	<property name="force.retrieve.environment" value="${force.environment}" />
	<if>
		<equals arg1="${force.deploy.environment}" arg2="$${force.deploy.environment}" />
		<then><var name="force.deploy.environment" unset="true" /></then>
	</if>
	<property name="force.deploy.environment" value="${force.environment}" />
	<!-- invariant force.environment, deploy and retrieve has a value set -->
	
	<propertyselector property="valid.environments"
		delimiter=","
		match="(\w+)\.username"
		select="\1"
		casesensitive="false"
	/>
	
	<if>
		<not><or>
		<equals arg1="${isCI}" arg2="true" />
		<equals arg1="${ignore}" arg2="credentials" />
		<equals arg1="${isSetup}" arg2="$${isSetup}" />
		<equals arg1="${run}" arg2="setup" />
		</or></not>
		<then>
			<trycatch>
				<try>
					<propertycopy name="_retrieve.username" from="${force.retrieve.environment}.username" />
					<propertycopy name="_retrieve.password" from="${force.retrieve.environment}.password" />
					<propertycopy name="_retrieve.serverurl" from="${force.retrieve.environment}.serverurl" />
					<propertycopy name="_retrieve.maxPoll" from="${force.retrieve.environment}.maxPoll" />
					
					<!-- if they have gotten here, then everything loaded correctly. -->
					<var name="retrieve.username" unset="true" />
					<var name="retrieve.password" unset="true" />
					<var name="retrieve.serverurl" unset="true" />
					<var name="retrieve.maxPoll" unset="true" />
					
					<propertycopy name="retrieve.username" from="_retrieve.username" />
					<propertycopy name="retrieve.password" from="_retrieve.password" />
					<propertycopy name="retrieve.serverurl" from="_retrieve.serverurl" />
					<propertycopy name="retrieve.maxPoll" from="_retrieve.maxPoll" />
					
					<!--
					<echo><![CDATA[
retrieve.username=${retrieve.username}
retrieve.password=${retrieve.password}
retrieve.serverurl=${retrieve.serverurl}
retrieve.maxPoll=${retrieve.maxPoll}
					]]></echo>
					-->
				</try>
				<catch>
					<echo><![CDATA[
Environment to retrieve from was set to [${force.retrieve.environment}]
]]></echo>
					<if>
						<equals arg1="${valid.environments}" arg2="$${valid.environments}" />
						<then>
							<echo><![CDATA[
but it doesn't seem like there are any credentials defined
]]></echo>
						</then>
						<else>
							<echo><![CDATA[
but that doesn't seem to match any of the previously defined environments: ${valid.environments}
]]></echo>
						</else>
					</if>
					
					<mm:Halt><![CDATA[
The retrieve environment was either specified by your source repository
(force.environment in resources/environment.settings)

Or specifically overridden in build.properties for this environment
(either force.environment or force.retrieve.environment)

Change one of these values before proceeding to a valid environment
or run the following to create new ones.
ant -Dignore=credentials checkCredentials
]]></mm:Halt>
				</catch>
			</trycatch>
			
			<!-- force.deploy.environment -->
			
			<trycatch>
				<try>
					<propertycopy name="_deploy.username" from="${force.deploy.environment}.username" />
					<propertycopy name="_deploy.password" from="${force.deploy.environment}.password" />
					<propertycopy name="_deploy.serverurl" from="${force.deploy.environment}.serverurl" />
					<propertycopy name="_deploy.maxPoll" from="${force.deploy.environment}.maxPoll" />
					
					<!-- if they have gotten here, then everything loaded correctly. -->
					<var name="deploy.username" unset="true" />
					<var name="deploy.password" unset="true" />
					<var name="deploy.serverurl" unset="true" />
					<var name="deploy.maxPoll" unset="true" />
					
					<propertycopy name="deploy.username" from="_deploy.username" />
					<propertycopy name="deploy.password" from="_deploy.password" />
					<propertycopy name="deploy.serverurl" from="_deploy.serverurl" />
					<propertycopy name="deploy.maxPoll" from="_deploy.maxPoll" />
					
					<!--
					<echo><![CDATA[
deploy.username=${deploy.username}
deploy.password=${deploy.password}                                                                     
deploy.serverurl=${deploy.serverurl}
deploy.maxPoll=${deploy.maxPoll}
					]]></echo>
					-->
				</try>
				<catch>
					<echo><![CDATA[

Environment to retrieve from was set to [${force.deploy.environment}]
]]></echo>
					<if>
						<equals arg1="${valid.environments}" arg2="$${valid.environments}" />
						<then>
							<echo><![CDATA[
but it doesn't seem like there are any deploy credentials defined
]]></echo>
						</then>
						<else>
							<echo><![CDATA[
but that doesn't seem to match any of the previously defined environments: ${valid.environments}
]]></echo>
						</else>
					</if>
					
					<mm:Halt><![CDATA[
The deploy environment was either specified by your source repository
(force.environment in resources/environment.settings)

Or specifically overridden in build.properties for this environment
(either force.environment or force.deploy.environment)

Change one of these values before proceeding to a valid environment
or run the following to create new ones.
ant -Dignore=credentials checkCredentials
]]></mm:Halt>
				</catch>
			</trycatch>
		</then>
	</if>
	
	
	
	<!--
	Determines if this app is expecting a different property file format.
	If it is, then stop the build, and instruct the user to reset the properties
	as the build may not work as expected.
	-->
	<if>
		<and>
			<not><equals arg1="${ignore}" arg2="version" /></not>
			<not><equals arg1="${build.prop.format}" arg2="" /></not><not><equals arg1="${build.prop.format}" arg2="$${build.prop.format}" /></not>
			<not><equals arg1="${build.prop.format.expected}" arg2="" /></not><not><equals arg1="${build.prop.format.expected}" arg2="$${build.prop.format.expected}" /></not>
			<not><equals arg1="${build.prop.format}" arg2="${build.prop.format.expected}" /></not>
		</and>
		<then>
			<mm:Halt><![CDATA[
Build.properties format version[${build.prop.format}]
does not match the expected version [${build.prop.format.expected}]

This means that your properties file may not match this program
and may not run as expected.

So this program will close.

Please replace the file:
* build.properties
with
* ${build.properties.template}
with the appropriate properties copied over

OR

run ant resetBuildProperties -Dignore=version
]]></mm:Halt>
		</then>
	</if>
	
	
	
	<!--
	target that allows for refreshing the environment credentials
	but can be used in the context of another target.
	If, for example, that target is refreshing those credentials
	and it should be run again
	-->
	<target name="checkCredentials">
		<!-- must be exactly the same code as above -->
		<if>
			<equals arg1="${force.retrieve.environment}" arg2="$${force.retrieve.environment}" />
			<then><var name="force.retrieve.environment" unset="true" /></then>
		</if>
		<property name="force.retrieve.environment" value="${force.environment}" />
		<if>
			<equals arg1="${force.deploy.environment}" arg2="$${force.deploy.environment}" />
			<then><var name="force.deploy.environment" unset="true" /></then>
		</if>
		<property name="force.deploy.environment" value="${force.environment}" />
		
				<trycatch>
					<try>
						<propertycopy name="_retrieve.username" from="${force.retrieve.environment}.username" />
						<propertycopy name="_retrieve.password" from="${force.retrieve.environment}.password" />
						<propertycopy name="_retrieve.serverurl" from="${force.retrieve.environment}.serverurl" />
						<propertycopy name="_retrieve.maxPoll" from="${force.retrieve.environment}.maxPoll" />
						
						<!-- if they have gotten here, then everything loaded correctly. -->
						<var name="retrieve.username" unset="true" />
						<var name="retrieve.password" unset="true" />
						<var name="retrieve.serverurl" unset="true" />
						<var name="retrieve.maxPoll" unset="true" />
						
						<propertycopy name="retrieve.username" from="_retrieve.username" />
						<propertycopy name="retrieve.password" from="_retrieve.password" />
						<propertycopy name="retrieve.serverurl" from="_retrieve.serverurl" />
						<propertycopy name="retrieve.maxPoll" from="_retrieve.maxPoll" />
						
						<!--
						<echo><![CDATA[
retrieve.username=${retrieve.username}
retrieve.password=${retrieve.password}
retrieve.serverurl=${retrieve.serverurl}
retrieve.maxPoll=${retrieve.maxPoll}
						]]></echo>
						-->
					</try>
					<catch>
						<echo><![CDATA[

Retrieve environment was set as [${force.retrieve.environment}]

but no matching retrieve credentials were defined in build.credentials

Adding them now...
]]></echo>
						<echo append="true" file="build.credentials"><![CDATA[

${force.retrieve.environment}.username=
${force.retrieve.environment}.password=
${force.retrieve.environment}.serverurl=
${force.retrieve.environment}.maxPoll=500
]]></echo>
						<var name="target.environment" unset="true" />
						<antcall target="setupCredentials">
							<param name="target.environment" value="${force.retrieve.environment}" />
						</antcall>
					</catch>
				</trycatch>
				
				<property file="build.credentials" />
				
				<trycatch>
					<try>
						<propertycopy name="_deploy.username" from="${force.deploy.environment}.username" />
						<propertycopy name="_deploy.password" from="${force.deploy.environment}.password" />
						<propertycopy name="_deploy.serverurl" from="${force.deploy.environment}.serverurl" />
						<propertycopy name="_deploy.maxPoll" from="${force.deploy.environment}.maxPoll" />
						
						<!-- if they have gotten here, then everything loaded correctly. -->
						<var name="deploy.username" unset="true" />
						<var name="deploy.password" unset="true" />
						<var name="deploy.serverurl" unset="true" />
						<var name="deploy.maxPoll" unset="true" />
						
						<propertycopy name="deploy.username" from="_deploy.username" />
						<propertycopy name="deploy.password" from="_deploy.password" />
						<propertycopy name="deploy.serverurl" from="_deploy.serverurl" />
						<propertycopy name="deploy.maxPoll" from="_deploy.maxPoll" />
						
						<!--
						<echo><![CDATA[
deploy.username=${deploy.username}
deploy.password=${deploy.password}
deploy.serverurl=${deploy.serverurl}
deploy.maxPoll=${deploy.maxPoll}
						]]></echo>
						-->
					</try>
					<catch>
						<echo><![CDATA[

Deploy environment was set as [${force.deploy.environment}]

but no matching retrieve credentials were defined in build.credentials

Adding them now...
]]></echo>
						<echo append="true" file="build.credentials"><![CDATA[

${force.deploy.environment}.username=
${force.deploy.environment}.password=
${force.deploy.environment}.serverurl=
${force.deploy.environment}.maxPoll=500
]]></echo>
						<var name="target.environment" unset="true" />
						<antcall target="setupCredentials">
							<param name="target.environment" value="${force.deploy.environment}" />
						</antcall>
					</catch>
				</trycatch>
	</target>
	
	
	<!-- 
	/**
	 *  Lists the current values for certain properties.
	 *  <p>Helpful for debugging</p>
	**/
	 -->
	<target name="prop">
		<echo><![CDATA[

testDeploy=${isTestDeploy}

src.path=${src.path}
resources.path=${resources.path}
base environment =${force.environment}
(defined as force.environment in resources/environment.settings to allow repo based switching
or build.properties to be specific to this project)
]]></echo>
		<if>
			<not><equals arg1="${force.retrieve.environment}" arg2="${force.environment}" /></not>
			<then>
				<echo><![CDATA[
retrieve environment override =${force.retrieve.environment}
(defined as force.retrieve.environment in build.properties)
]]></echo>
			</then>
		</if>
		<if>
			<not><equals arg1="${force.deploy.environment}" arg2="${force.environment}" /></not>
			<then>
				<echo><![CDATA[
deploy environment override =${force.deploy.environment}
(defined as force.deploy.environment in build.properties)
]]></echo>
			</then>
		</if>
		<echo><![CDATA[
retrieve.username=${retrieve.username}
retrieve.serverurl=${retrieve.serverurl}
retrieve.maxPoll=${retrieve.maxPoll}

deploy.username=${deploy.username}
deploy.serverurl=${deploy.serverurl}
deploy.maxPoll=${deploy.maxPoll}
]]></echo>

		<if>
			<not><equals arg1="${docChanges.lastCommit}" arg2="$${docChanges.lastCommit}" /></not>
			<then>
				<echo><![CDATA[

## Last commit used when showing the repository changes
docChanges.lastCommit=${docChanges.lastCommit}
]]></echo>
			</then>
		</if>

		<trycatch>
			<try>
				<if>
					<or>
						<equals arg1="${last.autodeploy}" arg2="$${last.autodeploy}" />
						<equals arg1="${last.autodeploy}" arg2="" />
					</or>
					<then>
						<propertycopy name="last.autodeploy" from="autodeploy.${force.deploy.environment}" />
					</then>
				</if>
				<echo><![CDATA[

Last AutoDeploy for ${force.deploy.environment}:
${last.autodeploy}
]]></echo>
			</try>
			<catch>
			</catch>
		</trycatch>
		<echo><![CDATA[


--

To change any settings, please run:
ant settings
]]></echo>
	</target>
	<target name="status" depends="prop" />
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	INITIAL SETUP CHECK
	(runs the code if there is no force or src folder)
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	-->
	
	<if>
		<and>
			<equals arg1="${isSetup}" arg2="$${isSetup}" />
			<not><equals arg1="${run}" arg2="setup" /></not>
		</and>
		<then>
			<!-- @TODO: figure out how to tell if there was nothing run.
			however it seems that 
			${ant.project.invoked-targets} doesn't work as expected
			-->
			<echo><![CDATA[

The project is not currently setup.

If you are on windows, run
setup.bat

If you're on Mac/*Nix, run
. setup.sh
(be sure to include the space)

]]></echo>
			<mm:Halt />
		</then>
	</if>
	
	
	
	
	<target name="setup">
		<if>
			<not><equals arg1="${isSetup}" arg2="$${isSetup}" /></not>
			<then>
				<antcall target="help" />
			</then>
			<else>
				<echo><![CDATA[
   _____ ______ _____   _____            _   _ _______ 
  / ____|  ____|  __ \ / ____|     /\   | \ | |__   __|
 | (___ | |__  | |  | | |         /  \  |  \| |  | |   
  \___ \|  __| | |  | | |        / /\ \ | . ` |  | |   
  ____) | |    | |__| | |____   / ____ \| |\  |  | |   
 |_____/|_|    |_____/ \_____| /_/    \_\_| \_|  |_|   

The purpose of the SFDC Ant project is to provide a simple
and efficient way of deploying and managing metadata with
SalesForce.com while keeping in sync with Version Control.

Press enter to continue.
]]></echo>
		
				<input addproperty="setupContinueA" />
				
				<mkdir dir="${packageLists.path}" />
				<copy file="${doxygen.template}" tofile="${doxygen.config.path}" />
				<copy file="${build.properties.template}" tofile="build.properties" />
				<copy file="${build.credentials.template}" tofile="build.credentials" />
				<copy file="${build.environment.template}" tofile="build.environment" />
				<copy file="${build.autodeploy.template}" tofile="build.autodeploy" />
				<copy file="${packageLists.template}" tofile="${packageLists.path}/sample_all.txt" />
				
				<echo><![CDATA[

There are two preferred methods of working with the SFDC Ant project:

1. Define custom paths for the location of the src and resource folders.

2. Create a symbolic link to the existing metadata under version control elsewhere.
	(Please note this option is not available for windows)

Which option would you like?
]]></echo>
				<input addproperty="setupOption" defaultvalue="1" validargs="1,2" />
				
				<if>
					<equals arg1="${setupOption}" arg2="2" />
					<then>
						<mkdir dir="${force.path}" />
						
						<echo><![CDATA[
Where does your the 'src' directory currently exist on your local machine?
# Note: this folder must be called 'src'.

For example, if the folder strucure is
./
	sfdc
		src
		resources
	sfdcantproject

A relative path could be:
../../sfdc/src

(Or, simply drag the 'src' folder on the terminal to specify the location)
]]></echo>
						<input addproperty="localSrcPath" />
						<propertyregex property="localSrcPath"
							input="${localSrcPath}"
							override="true"
							regexp="\s+$"
							replace=""
						/>
						<if><or>
							<equals arg1="${localSrcPath}" arg2="$${localSrcPath}" />
							<equals arg1="${localSrcPath}" arg2="" />
						</or><then>
							<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
						</then></if>
						
						<exec executable="ln" dir="${force.path}">
							<arg value="-s" />
							<arg value="${localSrcPath}" />
							<arg value="src" />
						</exec>
						
						<echo><![CDATA[
		A symbolic link to your existing code base at:
		${localSrcPath}
		
		has been created at:
		${src.path}
						]]></echo>
						
						<echo><![CDATA[
Where should the extracted static resources be stored?

For example, if the folder strucure is
./
	sfdc
		src
		resources
	sfdcantproject

A relative path could be:
../sfdc/resources

(Or, simply drag the folder on the terminal to specify the location)
]]></echo>
						<input addproperty="localResourcePath" />
						<propertyregex property="localResourcePath"
							input="${localResourcePath}"
							override="true"
							regexp="\s+$"
							replace=""
						/>
						<if><or>
							<equals arg1="${localResourcePath}" arg2="$${localResourcePath}" />
							<equals arg1="${localResourcePath}" arg2="" />
						</or><then>
							<mkdir dir="${resources.path}" />
						</then><else>
							<exec executable="ln" dir=".">
								<arg value="-s" />
								<arg value="${localResourcePath}" />
								<arg value="${resources.dir}" />
							</exec>
						</else></if>
					</then>
					<else>
						<!-- unescape the src.path in the environment and update it -->
						<replaceregexp encoding="UTF-8" file="build.environment"
							match="^[ \t]*#src.path=" replace="src.path="
							flags="img"
						/>
						<echo><![CDATA[
Where does your the 'src' directory currently exist on your local machine?

For example, if the folder strucure is
./
	sfdc
		src
		resources
	sfdcantproject

A relative path could be:
../../sfdc/src

(Note, an extra ../ is needed for relative paths.)

(Or, simply drag the folder on the terminal to specify the location)
]]></echo>
						<input addproperty="localSrcPath" />
						<propertyregex property="localSrcPath"
							input="${localSrcPath}"
							override="true"
							regexp="\s+$"
							replace=""
						/>
						<if><or>
							<equals arg1="${localSrcPath}" arg2="$${localSrcPath}" />
							<equals arg1="${localSrcPath}" arg2="" />
						</or><then>
							<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
						</then></if>
						
						<antcall target="changePropertyFileValue">
							<param name="propertyFile.path" value="build.environment" />
							<param name="property.name" value="src.path" />
							<param name="property.value" value="${localSrcPath}" />
						</antcall>
						<var name="src.path" unset="true" />
						<property name="src.path" value="${localSrcPath}" />
						
						
						<!-- unescape the resources.path in the environment and update it -->
						<replaceregexp encoding="UTF-8" file="build.environment"
							match="^[ \t]*#resources.path=" replace="resources.path="
							flags="img"
						/>
						<echo><![CDATA[
Where should the extracted static resources be stored?

For example, if the folder strucure is
./
	sfdc
		src
		resources
	sfdcantproject

A relative path could be:
../sfdc/resources

(Or, simply drag the folder on the terminal to specify the location)
]]></echo>
						<input addproperty="localResourcePath" />
						<propertyregex property="localResourcePath"
							input="${localResourcePath}"
							override="true"
							regexp="\s+$"
							replace=""
						/>
						<if><or>
							<equals arg1="${localResourcePath}" arg2="$${localSrcPath}" />
							<equals arg1="${localResourcePath}" arg2="" />
						</or><then>
							<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
						</then></if>
						
						<antcall target="changePropertyFileValue">
							<param name="propertyFile.path" value="build.environment" />
							<param name="property.name" value="resources.path" />
							<param name="property.value" value="${localResourcePath}" />
						</antcall>
						<var name="resources.path" unset="true" />
						<property name="resources.path" value="${localResourcePath}" />
						
						<mkdir dir="${src.path}" />
						<copy file="${force.package.template}" tofile="${force.package.path}" />
					</else>
				</if>
				
				<if>
					<not><equals arg1="${localSrcPath}" arg2="$${localSrcPath}" /></not>
					<then>
						<antcall target="changePropertyFileValue">
							<param name="propertyFile.path" value="build.properties" />
							<param name="property.name" value="codeHome" />
							<param name="property.value" value="${localSrcPath}" />
						</antcall>
					</then>
				</if>
				
				<!-- reset properties set by the environment.settings -->
				<var name="force.environment" unset="true" />
				<var name="force.retrieve.environment" unset="true" />
				<var name="force.deploy.environment" unset="true" />
				<var name="environment.settings.path" unset="true" />
				<property name="environment.settings.path" value="${resources.path}/${environment.settings.file}" />
				
				<property file="build.environment" />
				<property file="build.properties" />
				<property file="${environment.settings.path}" />
				
				<echo><![CDATA[

To communicate with SalesForce.com, you will need to configure the build.properties
with your credentials.
]]></echo>
				<if>
					<not><equals arg1="${force.environment}" arg2="$${force.environment}" /></not>
					<then>
						<echo><![CDATA[
current environment - ${force.environment}
]]></echo>
					</then>
				</if>
				
				<echo><![CDATA[

It is recommended that this be accomplished now,
would you like to continue?
]]></echo>
				<input addproperty="setupCredentials" defaultvalue="y" validargs="y,n" />
				<if>
					<equals arg1="${setupCredentials}" arg2="y" />
					<then>
						<antcallback target="checkCredentials" inheritall="true" return="retrieveCredentialsSetup,deployCredentialsSetup" />
					</then>
				</if>
				
				<echo><![CDATA[

Your project should now be setup.

The following is a general folder structure:

	packageLists: the folder that contains files that represent packages in simpler format than packages.
	
	resources: contains extracted static resources (including zips and simple files) for easier deployment.
	
	force: contains all metadata used by the project. (Resources are compiled here before deployment)
	
	deploy: the folder used when performing a deployment.

For any questions, comments or feedback - please contact:
Paul Roth (proth@salesforce.com)
]]></echo>
			</else>
		</if>
	</target>
	
	
	
	<!--
	/**
	 *  Migrates the old properties over to the new properties file
	**/
	-->
	<target name="resetBuildProperties">
		<echo><![CDATA[
Overwriting build.properties with the latest template
]]></echo>
		
		<property name="target.build.properties" value="build.properties" />
		<copy file="build.properties" tofile="${tmp.path}/build_${timestamp.numeric}.properties" overwrite="true" />
		<copy file="${build.properties.template}" tofile="${target.build.properties}" overwrite="true" />
		
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="isTestDeploy" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="SFDC_VERSION" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="codeHome" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="recent.list" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="codeHomeRepoOffset" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="autodeploy.profiles" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="autodeploy.autoLatestCommit" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="docChanges.lastCommit" /></antcall>
		<antcall target="resetBuildProperty" inheritall="true"><param name="property.name" value="docAll_targets" /></antcall>
	</target>
	
	
	
	<!--
	/**
	 *  Migrates an individual property to the new properties file
	 *  @param property.name
	 **/
	-->
	<target name="resetBuildProperty">
		<echo>Checking if ${property.name} was set</echo>
		
		<trycatch><try>
			<var name="property.value" unset="true" />
			<propertycopy name="property.value" from="${property.name}" />
			
			<echo><![CDATA[ Migrating old value of '${property.name}': [${property.value}] ]]></echo>
			
			<replaceregexp encoding="UTF-8" file="${target.build.properties}"
				match="(^|${n})[ \t]*#?${property.name}\s*=.*"
				replace="\1${property.name}=${property.value}"
				flags="img"
			/>
		</try><catch>
			<echo><![CDATA[ [${property.name}] not defined within the old.build.properties ]]></echo>
		</catch></trycatch>
	</target>
	
	
	
	<target name="reverseSetup">
		<delete file="build.properties" />
		<delete dir="${force.path}" />
		<delete dir="${resources.path}" />
		<delete dir="${packageLists.path}" />
	</target>
	
	
	
	<target name="test">
		<echo><![CDATA[
First, we'll verify your src folder is setup correctly.
(Such as if a symbolic link is not working right)

${enterContinue}
]]></echo>
		<input addproperty="test1" />
		
		<trycatch>
			<try>
				<mkdir dir="${src.path}/sampleMetadataFolder" />
				<delete dir="${src.path}/sampleMetadataFolder" />
			</try>
			<catch>
				<mm:Halt><![CDATA[Seems we cannot create a folder ${src.path}/sampleMetadataFolder.${n}Try checking  ${src.path} to make sure the link is right.]]></mm:Halt>
			</catch>
		</trycatch>
		
		
		<echo><![CDATA[
First, we'll verify your resources folder is setup correctly.
(Such as if a symbolic link is not working right)

${enterContinue}
]]></echo>
		<input addproperty="test2" />
		
		<trycatch>
			<try>
				<mkdir dir="${resources.dir}/sampleMetadataFolder" />
				<delete dir="${resources.dir}/sampleMetadataFolder" />
			</try>
			<catch>
				<mm:Halt><![CDATA[Seems we cannot create a folder ${src.path}/sampleMetadataFolder.${n}Try checking  ${resources.dir} to make sure it is right.]]></mm:Halt>
			</catch>
		</trycatch>
		
		<echo><![CDATA[
Next, we'll try creating an apex class called TEST1234

This can normally be run by
>ant template

${enterContinue}
]]></echo>
		<input addproperty="test3" />
		
		<property name="filePackage.dir" value="classes" />
		<property name="fileName" value="TEST1234" />
		
		<!-- we could call template with those as parameters, but some users don't have any files in their src folder -->
		
		<delete dir="${tmp.deploy.path}" />
		<mkdir dir="${tmp.deploy.path}/${filePackage.dir}" />
		
		<mm:SFDC_ConvertFolderToExtension folderName="${filePackage.dir}" targetProperty="fileExtension" />
		<property name="target.path" value="${tmp.deploy.path}/${filePackage.dir}/${fileName}${fileExtension}" />
		<property name="source.path" value="${meta.path}/${filePackage.dir}.template" />
		
		<property name="target.meta.path" value="${tmp.deploy.path}/${filePackage.dir}/${fileName}${fileExtension}${meta_suffix}" />
		<property name="source.meta.path" value="${meta.path}/${filePackage.dir}.meta.template" />
		
		<copy file="${source.path}" tofile="${target.path}" />
		<copy file="${source.meta.path}" tofile="${target.meta.path}" />
		
		<replaceregexp encoding="UTF-8" file="${target.path}"
			match="##VERSION##"
			replace="${SFDC_VERSION}"
			flags="img"
		/>
		<replaceregexp encoding="UTF-8" file="${target.path}"
			match="##FILENAME##"
			replace="${fileName}"
			flags="img"
		/>
		
		<replaceregexp encoding="UTF-8" file="${target.meta.path}"
			match="##VERSION##"
			replace="${SFDC_VERSION}"
			flags="img"
		/>
		<replaceregexp encoding="UTF-8" file="${target.meta.path}"
			match="##FILENAME##"
			replace="${fileName}"
			flags="img"
		/>
		
		<!-- create the package -->
		<echo file="${tmp.deploy.path}/${force.package.file}">&lt;?xml version="1.0" ?&gt;
&lt;Package xmlns="http://soap.sforce.com/2006/04/metadata"&gt;
	&lt;version&gt;${SFDC_VERSION}&lt;/version&gt;
	&lt;types&gt;
		&lt;name&gt;ApexClass&lt;/name&gt;
		&lt;members&gt;${fileName}&lt;/members&gt;
	&lt;/types&gt;
&lt;/Package&gt;</echo>
		
		<echo><![CDATA[
Next we'll try test deploying to your current org.

You can normally run this through
>ant deploy
or
>ant deployFromList
if you have created a packageList

Run
>ant packageList for a couple of options involving package lists.

${enterContinue}
]]></echo>
		<input addproperty="test4" />
		
		<antcall target="validateDeployCredentials" />
		
		<trycatch>
			<try>
				<sf:deploy username="${deploy.username}" password="${deploy.password}" serverurl="${deploy.serverurl}"
					deployRoot="${tmp.deploy.path}" maxPoll="${deploy.maxPoll}" pollWaitMillis="5000" checkOnly="true"
				>
				</sf:deploy>
			</try>
			<catch>
				<mm:Halt><![CDATA[Seems we cannot do a test deploy. Try checking your deploy credentials in build.credentials or which environment is in use. (See Readme for more details).]]></mm:Halt>
			</catch>
		</trycatch>
		
		<echo><![CDATA[
Next we'll try retrieving from your current org.

You can normally run this through
>ant refresh
or
>ant refreshFromList
if you have created a packageList

Run
>ant packageList for a couple of options involving package lists.

${enterContinue}
]]></echo>
		<input addproperty="test5" />
		
		<!-- remove the old package -->
		<delete dir="${tmp.retrieve.path}" />
		<echo file="${tmp.retrieve.path}/${force.package.file}">&lt;?xml version="1.0" ?&gt;
&lt;Package xmlns="http://soap.sforce.com/2006/04/metadata"&gt;
	&lt;version&gt;${SFDC_VERSION}&lt;/version&gt;
	&lt;types&gt;
		&lt;name&gt;CustomObject&lt;/name&gt;
		&lt;members&gt;Account&lt;/members&gt;
	&lt;/types&gt;
&lt;/Package&gt;</echo>
		
		<trycatch>
			<try>
				<sf:retrieve username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}"
					retrieveTarget="${tmp.retrieve.path}" unpackaged="${tmp.retrieve.path}/${force.package.file}"
				/>
			</try>
			<catch>
				<mm:Halt><![CDATA[Seems we cannot do a test retrieve. Try checking your retrieve credentials in build.credentials or which environment is in use. (See Readme for more details).]]></mm:Halt>
			</catch>
		</trycatch>
		
		<echo><![CDATA[




Congrats!

You appear to be all setup.
]]></echo>
	</target>
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	Aggregate targets
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->	
	
	
	
	
	<target name="packageList"
		description="high level methods for dealing with package lists"
	>
		<echo><![CDATA[
Package Lists provide a way to specify a set of files to retrieve/deploy/extract/ect.

makePackageListAll              - Creates a package list for all files in src directory.
                                    (shortcut for addToPackageList with filter of *)
createRevisionList              - Creates a packageList based on a range of git revisions.

addFileToPackageList            - Adds a specific file to a package list
addToPackageList                - Adds files that match a filter to a package list
removePackageList               - Deletes a package List
listPackageList                 - lists the files in a packageList

refreshFromList                 - Retrieves/Refreshes all files within the packageList locally.

applyPackageListToPackage       - Merges the package list into the current package

deployFromList                  - Compresses all files from a packageList, prepares them for deployment.

Which would you like to do?]]></echo>
		<input addproperty="whichAction" validargs="makePackageListAll,createRevisionList,addToPackageList,addFileToPackageList,removePackageList,listPackageList,applyPackageListToPackage,deployFromList"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	<!-- 
	/**
	 *  creates a packageList from a file
	**/
	 -->
	<target name="addToPackageList"
		description="creates a packageList from a file"
	>
		<echo><![CDATA[
How would you like to add the file?
1 - Pick from a local file
2 - Search locally
3 - Search metadata
4 - Manual
]]></echo>
		<input addproperty="addFile.type" validargs="1,2,3,4" />
		<switch value="${addFile.type}">
			<case value="1">
				<antcall target="addToPackageListSelect" inheritall="true" />
			</case>
			<case value="2">
				<antcall target="addToPackageListPattern" inheritall="true" />
			</case>
			<case value="3">
				<antcall target="addToPackageListSearch" inheritall="true" />
			</case>
			<case value="4">
				<antcall target="addToPackageListManual" inheritall="true" />
			</case>
			<default>
				<mm:Halt />
			</default>
		</switch>
	</target>
	
	
	
	
	<target name="retrieveDeploy"
		description="High level methods refreshing/deploying/storing"
	>
		<echo><![CDATA[
refresh                         - Re-retrieves all files currently under force/src in-place.
refreshFromList                 - Retrieves all files from a packageList ant extracts static resources

resetRefresh                    - Removes all files currently under the src, and refreshes from SalesForce (showing files deleted in SFDC)

deploy                          - Deploys the files under the deploy folder
deployFromList                  - Compresses all files from a packageList, prepares them in the deploy folder.

shelveDeploy                    - stores the deploy folder to be used at a later point
loadDeploy                      - loads a previously shelved deploy folder.

Which would you like to do?]]></echo>
		<input addproperty="whichAction" validargs="refresh,refreshFromList,resetRefresh,deploy,deployFromList"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<target name="refreshFiles"
		description="High level methods refreshing"
	>
		<echo><![CDATA[
Common means for deploying files are:

* Add whichever files to a packageList
	(either through addToPackageList, createRevisionList, or manually)

* Optionally retrieve the files from the server
	(such as through refreshFromList or resetRefresh)

* deployFromList
	(this stages the files in a packageList into the deploy folder and then deploys)

* deploy
	(this deploys all files in the deploy folder)

--

refresh                         - Re-retrieves all files currently under force/src in-place.
refreshFromList                 - Retrieves all files from a packageList ant extracts static resources

resetRefresh                    - Removes all files currently under the src, and refreshes from SalesForce (showing files deleted in SFDC)

Which would you like to do?]]></echo>
		<input addproperty="whichAction" validargs="refresh,refreshFromList,resetRefresh,deploy,deployFromList"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	<target name="retrieveFiles" depends="refreshFiles" />
	
	
	
	
	<target name="deployFiles"
		description="High level methods deploying/storing"
	>
		<echo><![CDATA[
Common means for deploying files are:

* Add whichever files to a packageList
	(either through addToPackageList, createRevisionList, or manually)

* Optionally retrieve the files from the server
	(such as through refreshFromList or resetRefresh)

* deployFromList
	(this stages the files in a packageList into the deploy folder and then deploys)

* deploy
	(this deploys all files in the deploy folder)

--

deployFromList                  - Compresses all files from a packageList, prepares them in the deploy folder.

deploy                          - Deploys the files under the deploy folder

shelveDeploy                    - stores the deploy folder to be used at a later point
loadDeploy                      - loads a previously shelved deploy folder.

Which would you like to do?]]></echo>
		<input addproperty="whichAction" validargs="refresh,refreshFromList,resetRefresh,deploy,deployFromList"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<target name="settings"
		description="high level methods for dealing with package lists"
	>
		<echo><![CDATA[
testDeploy                            - Defines whether the deployments should be tested or carried out.

createEnvironmentSettings             - Creates the environment settings for current branch.
										(this allows for automatic environment detection from ant)

environment                           - Defines the default environment that should be used.

                                      - (Please see the readme how these interact with the environment)
retrieve                              - Defines environment used to retrieve metadata from SFDC
deploy                                - Defines environment used to deploy metadata TO SFDC

resetCredentials                      - Allows updating of credentials for a specific environment

addResourceTranslation                - Defines what a static resource translates to: either a file or a zip
                                        ( this is used by extractResources )

lastChangeCommit                      - Defines the (non-inclusive) commit to use to check changes against
                                        (see docChanges)

Which would you like to do?]]></echo>
		<input addproperty="whichAction" validargs="testDeploy,environment,retrieve,resetCredentials,deploy,addResourceTranslation,createEnvironmentSettings,lastChangeCommit"
		/>
		
		<switch value="${whichAction}">
			<case value="environment">
				<antcall target="setupEnvironment" />
			</case>
			<case value="retrieve">
				<antcall target="setupRetrieveCredentials" />
			</case>
			<case value="deploy">
				<antcall target="setupDeployCredentials" />
			</case>
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	<target name="clean"
		description="High level cleaning targets"
	>
		<echo><![CDATA[
cleanDeploy               - Cleans/Removes the deployment directory
cleanOutput               - cleans the documentation directory
cleanDocs                 - synonym of the cleanOutput
cleanGit                  - removes all git changes

]]></echo>
		<input addproperty="whichAction" validargs="cleanDeploy,cleanOutput,cleanDocs"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<target name="list"
		description="Lists different types of information"
	>
		<echo><![CDATA[
all        - Lists all metadata available from the org
types      - Lists all the metadata types available from the org
files      - Lists all metadata files for a specific metadata type

listFileChanges     - Lists the changes on a specific files for a revision range
listGitCommits      - Lists the changes that occurred between a revision range

packageList			- Lists the contents of a package list
package				- Lists the contents of the package

Which would you like to do?]]></echo>
		<input addproperty="whichAction"
			validargs="all,types,files,listFileChanges,listGitCommits,packageList,package"
		/>
		
		<switch value="${whichAction}">
			<case value="all">
				<antcall target="listMetadata" />
			</case>
			<case value="types">
				<antcall target="listMetadataTypes" />
			</case>
			<case value="files">
				<antcall target="listMetadataFiles" />
			</case>
			<case value="packageList">
				<antcall target="listPackageList" />
			</case>
			<case value="package">
				<antcall target="listPackageToChange" />
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<!--
	/**
	 *  Prints a list of metadata response types
	 *  @visibility Internal
	 *  @return metadataSimpleResults
	 **/
	-->
	<target name="modifyPackage">
		<echo><![CDATA[
Note: this adds the members to the package and not to a package list.

addPackageMember        - adds a specific MetadataType/Member to the current package
addPackageType          - adds a filtered list of metadata types available from SFDC
addAllPackageTypes      - adds all metadata types available for an org
                        
addStandardObjects      - adds the standard custom objects to the package
addDocMetadata          - adds the default metadata used for documentation using wildcards (so it will pull all - even new)
addDocMetadataByName    - adds the metadata used for documentation with each entry added by name (so it can be reduced if desired)
                        
removePackageMember     - Removes a particular MetadataType/Member from a package.
removePackageType       - Removes an entire MetadataType from a package

applyPackageListToPackage       - Merges the package list into the current package

]]></echo>
		<input addproperty="whichAction"
			validargs="addPackageMember,addPackageType,addAllPackageTypes,addStandardObjects,addDocMetadata,addDocMetadataByName,removePackageMember,removePackageType,applyPackageListToPackage"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<!--
	/**
	 *  Prints a list of destructive changes
	 *  @visibility Internal
	 *  @return metadataSimpleResults
	 **/
	-->
	<target name="destroy">
		<echo><![CDATA[
Note: these targets destroy metadata in SalesForce.com.
Please be cautious.

All deployment changes made in ${deploy.path} prior to deployment.

destroyUsingList          - Creates a destructive change deployment from a package list.

deleteUsingList           - Deletes a set of files based on a packageList

clearApex                 - Clears all apex from the deploy folder
							(used to allow for renaming of fields)
							(only updates the deploy folder)

]]></echo>
		<input addproperty="whichAction"
			validargs="destroyUsingList,deleteUsingList,clearApex"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	<target name="delete" depends="destroy" />
	
	
	
	
	<!--
	/**
	 *  Performs git operations on the source path
	 *  @visibility Internal
	 **/
	-->
	<target name="git">
		<echo><![CDATA[
GIT related tasks.

mergeCurrentCode                   - Uses DiffMerge to show/modify the changes between current code and HEAD on a file.
                                   
listFileChanges                    - Lists the changes on a specific files for a revision range
listGitCommits                     - Lists the changes that occurred between a revision range
                                   
gitCmd                             - Runs an arbitrary git command on the source directory
                                   
createRevisionList                 - Creates a packageList from the changes in a revision range.

]]></echo>
		<input addproperty="whichAction"
			validargs="mergeCurrentCode,listFileChanges,listGitCommits,gitCmd,createRevisionList"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<!--
	/**
	 *  Autodeploy operations
	 *  @visibility Internal
	 **/
	-->
	<target name="auto">
		<echo><![CDATA[
Autodeploy related tasks

lastAutoDeploy     - Specifies the starting commit for the next autoDeploy
                    (This should be done before the first run of autoDeploy
                    and will be updated after each successful autoDeploy)

autoDeploy         - Creates a package list from the last autodeploy commit, prepares and deploys it out.
                    (This will deploy all code from:
                    the start commit, specified by the lastAutoDeploy, to HEAD
                    Please see the AutoDeploy section of the README for more info.)

autoDeployManual   - Allows prompts for specifying the start and end deployment ranges.
                    (This can be useful if only autoDeploying a range,
                    such as if a new release occurred)


]]></echo>
		<input addproperty="whichAction"
			validargs="autoDeploy,lastAutoDeploy,autoDeployManual"
		/>
		
		<switch value="${whichAction}">
			<case value="">
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<default>
				<antcall target="${whichAction}" />
			</default>
		</switch>
	</target>
	
	
	
	
	<!--
	/**
	 *  SimpleTask - Creates reports
	 **/
	-->
	<target name="doc" description="SimpleTask - Creates documentation reports">
		<echo><![CDATA[
retrieveProfiles - prepares to run reports by retrieving profiles and objects
					(as these are often used by the reports)

clean - Removes the doc folder and all generated docs.
matrix    - creates a profile Create/Read/Updated/Delete matrix
flows     - Runs an XLST report on all (visual work) flows
objects   - Runs an XSLT report on all objects
profiles  - Runs an XSLT report on all profiles
workflows - Runs an XSLT report on all workflows
workbooks - Runs an XSLT report to create workbooks for all objects
code      - Runs a code report using ApexDoc
changes   - Runs a report showing the changes since last run.

archiveDocs - Zips the documentation previously generated.

What report would you like to run?
]]></echo>
		
		<if>
			<not>
				<available file="${reportResources.target.path}" type="dir" />
			</not>
			<then>
				<copy overwrite="true" todir="${reportResources.target.path}">
					<fileset dir="${reportResources.path}" />
				</copy>
			</then>
		</if>
		
		<input
			addproperty="whichAction"
			defaultvalue="all"
			validargs="clean,retrieveProfiles,flows,matrix,objects,profiles,workflows,workbooks,code,changes,all,archiveDocs"
		/>
		<switch value="${whichAction}">
			<case value="" >
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</case>
			<case value="clean">
				<antcall target="cleanDocs" inheritall="true" />
			</case>
			<case value="retrieveProfiles">
				<antcall target="retrieveProfiles" inheritall="true" />
			</case>
			<case value="matrix">
				<antcall target="matrix" inheritall="true" />
			</case>
			<case value="flows">
				<antcall target="docFlows" inheritall="true" />
			</case>
			<case value="objects">
				<antcall target="docObjects" inheritall="true" />
			</case>
			<case value="profiles">
				<antcall target="docProfiles" inheritall="true" />
			</case>
			<case value="workflows">
				<antcall target="docWorkflows" inheritall="true" />
			</case>
			<case value="workbooks">
				<antcall target="docWorkbooks" inheritall="true" />
			</case>
			<case value="code">
				<antcall target="docCode" inheritall="true" />
			</case>
			<case value="changes">
				<antcall target="docDiffChanges" inheritall="true" />
			</case>
			<case value="all">
				<antcall target="docAll" inheritall="true" />
			</case>
			<case value="archiveDocs">
				<antcall target="archiveDocs" inheritall="true" />
			</case>
		</switch>
		
		<if>
			<not><or><equals arg1="${whichAction}" arg2="all" /><equals arg1="${whichAction}" arg2="archiveDocs" /></or></not>
			<then>
				<antcall target="updateIndices" inheritall="true" />
			</then>
		</if>
	</target>
		
	<target name="updateIndices"
		description="Updates the output indices for the different reports"
	>
		<echo><![CDATA[
Would you like to update the global index?
]]></echo>
		
		<copy overwrite="true" file="${index.template.path}" tofile="${index.path}" />
		
		<input addproperty="updateIndex" validargs="y,n" defaultvalue="y" />
		<if>
			<equals arg1="${updateIndex}" arg2="y" />
			<then>
				<echo><![CDATA[
Updating global index]]></echo>
				
				<echo file="${tmp.index.path}"></echo>
				<if>
					<available file="${object.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${object.result.dir}/${index.file}" >Object Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${flow.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${flow.result.dir}/${index.file}" >Flow Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${workflow.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${workflow.result.dir}/${index.file}" >Workflow Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${code.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${code.result.dir}/${index.file}" >Code Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${matrix.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${matrix.result.dir}/${index.file}" >Matrix Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${workbook.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${workbook.result.dir}/${index.file}" >Workbook Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${profile.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${profile.result.dir}/${index.file}" >Profile Report</a></li>]]></echo>
					</then>
				</if>
				<if>
					<available file="${change.result.path}" type="dir" />
					<then>
						<echo file="${tmp.index.path}" append="true"><![CDATA[
<li><a href="../${change.result.dir}/${index.file}" >Change Report</a></li>]]></echo>
					</then>
				</if>
				
				<!-- create the index -->
				<var name="globalIndex" unset="true" />
				<loadfile srcfile="${tmp.index.path}" property="globalIndex" />
				
				<replaceregexp encoding="UTF-8" flags="img" 
					match="&lt;StartGlobalNav\s*&gt;"
					replace="&lt;StartGlobalNav†&gt;"
				>
					<fileset dir="${output.path}" includes="**/*.html" />
				</replaceregexp>
				
				<replaceregexp encoding="UTF-8" flags="img" 
					match="&lt;/EndGlobalNav\s*&gt;"
					replace="&lt;/†EndGlobalNav&gt;"
				>
					<fileset dir="${output.path}" includes="**/*.html" />
				</replaceregexp>
				
				<replaceregexp encoding="UTF-8" flags="img" 
					match="&lt;StartGlobalNav†[^†]+†EndGlobalNav&gt;"
					replace="&lt;StartGlobalNav&gt;&lt;/StartGlobalNav&gt;${globalIndex}&lt;EndGlobalNav&gt;&lt;/EndGlobalNav&gt;"
				>
					<fileset dir="${output.path}" includes="**/*.html" />
				</replaceregexp>
				
				<replaceregexp encoding="UTF-8" flags="img" 
					match="\{\{DocGenDate\}\}"
					replace="${timestamp.readible}"
				>
					<fileset dir="${output.path}" includes="**/*.html" />
				</replaceregexp>
				
				
			</then>
		</if>
		
		<replaceregexp encoding="UTF-8" file="${index.path}"
			match="\.\./"
			replace=""
			flags="img"
		/>
	</target>
	<target name="updateIndex" depends="updateIndices" />
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	HIGH LEVEL TARGETS
	(These are aggregate targets that call Medium level targets)
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!-- 
	/**
	 *  Uses the property lists to extract groups of static resources
	 *  in a set.
	 *  <p>To Add more lists, simply add more properties</p>
	**/
	 -->
	<target name="extractResources"
		description="Uses the property lists to compress groups of static
		resources in a set"
	>
		<antcallback target="requestFileList" return="fileList.path" />
		
		<antcallback target="getFileListResources" return="staticresource.list">
			<param name="fileList.path" value="${fileList.path}" />
		</antcallback>
		
		<foreach list="${staticresource.list}"
			target="extractResources_internal"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
		
		<echo>

SUCCESS.

Extracted: ${staticresource.list}</echo>
	</target>
	
	<!-- synonyms for common misspellings -->
	<target name="expandResources" depends="extractResources" />
	
	
	
	
	<!-- 
	/**
	 *  Uses the property lists to compress groups of static resources
	 *  in a set.
	 *  <p>To Add more lists, simply add more properties</p>
	**/
	 -->
	<target name="compressResources"
		description="Uses the property lists to compress groups of static
		resources in a set"
	>
		<antcallback target="requestFileList" return="fileList.path" />
		
		<antcallback target="getFileListResources" return="staticresource.list">
			<param name="fileList.path" value="${fileList.path}" />
		</antcallback>
		
		<foreach list="${staticresource.list}"
			target="compressResources_internal"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
		
		<echo>

SUCCESS.

Compressed: ${staticresource.list}</echo>
	</target>
	
	<!-- synonyms for common misspellings -->
	<target name="compileResources" depends="compressResources" />
	
	
	
	
	<!-- 
	/**
	 *  Sends the deployment out to SalesForce.com
	**/
	 -->
	<target name="deploy"
		description="Sends the deployment out"
	>
		<if>
			<or>
				<istrue value="${isTestDeploy}" />
			</or>
			<then>
				<echo>#	#	#	#	#	#	#
WARNING: Is Test Deploy

${deploy.username}
${deploy.serverurl}

To no longer do a test deploy run:
ant testDeploy
#	#	#	#	#	</echo>
			</then>
			<else>
				<echo>#	#	#	#	#	#	#
WARNING: This is a live deploy

${deploy.username}
${deploy.serverurl}
</echo>
				<antcall target="pauseContinue" />
			</else>
		</if>
		
		<antcall target="validateDeployCredentials" />

		<sf:deploy username="${deploy.username}" password="${deploy.password}" serverurl="${deploy.serverurl}"
			deployRoot="${deploy.path}" maxPoll="${deploy.maxPoll}" pollWaitMillis="5000" checkOnly="${isTestDeploy}" logType="None"
		>
			<!-- TODO: separate this task out to allow individual running of tests.
			It is rather ridiculous that we can't send this list as a parameter instead
			DO NOT COMMIT WITH RUN TESTS AS THIS CODE IS SHARED
			
			set logType to Db or Debugonly to show debugging levels
			http://www.salesforce.com/us/developer/docs/daas/salesforce_migration_guide.pdf "Deploying Changes to a Salesforce Organization"
			for additional options
			
			<runTest>FS_TestClassName</runTest>
			<runTest>FS_TestClassName2</runTest>
			-->
		</sf:deploy>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Cleans/Removes the deployment directory
	**/
	 -->
	<target name="cleanDeploy"
		description="Cleans/Removes the deployment directory"
	>
		<delete dir="${deploy.path}" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Removes all git changes in the src directory.
	 *  <p>This can occasionally be desired from an automation standpoint</p>
	**/
	-->
	<target name="cleanGit"
		description="Cleans/Removes all git changes from src"
	>
		<echo><![CDATA[This will remove all uncommitted changes from your sfdc src directory.
]]></echo>
		<exec executable="git" dir="${src.path}">
			<arg line="clean -n -d -x ." />
		</exec>
		<antcall target="pauseContinue" />
		<exec executable="git" dir="${src.path}">
			<arg line="clean -f -d -x ." />
		</exec>
		<echo>Cleaned ${src.path}</echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Refreshes all code currently in version control with that in SalesForce.com
	**/
	 -->
	<target name="refresh" description="Refreshes all code currently in version control with that in SalesForce.com">
		<antcall target="validateRetrieveCredentials" />
		
		<echo><![CDATA[
You are about to refresh from
${retrieve.username}
${retrieve.serverurl}
]]></echo>
		<antcall target="pauseContinue" />
		
		<antcall target="heapWarning" />
		
		<echo><![CDATA[
Refreshing...
]]></echo>
		<sf:retrieve username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}"
			retrieveTarget="${src.path}" unpackaged="${force.package.path}"
		/>
	</target>
	
	
	
	
	<!--
	/**
	 *  Removes all files from the SRC folder prior to doing a refresh as a way to
	 *  expose files deleted in SalesForce.
	 *  
	 *  <p>This is often used for automated documentation without the need for all
	 *  files to be continually updated in version control.  However, managing a
	 *  project using this task means that the communication is not there to begin with.</p>
	**/
	-->
	<target name="resetRefresh"
		description="Removes all files from the src folder prior to doing a refresh to expose files deleted in SalesForce."
		depends="resetSrc,refresh"
	>
	</target>
	
	
	
	
	<!--
	/**
	 *  Refreshes all the files needed for the profile,
	 *  but only against those currently in the src/version control.
	 * 
	 *  <p>This helps to avoid the profile breaks that commonly happen
	 *  when doing automated deployments / migrations.</p>
	 *  
	**/
	-->
	<target name="refreshProfiles"
		description="Refreshes the profiles against what is currently in src/version control"
	>
		<antcall target="validateRetrieveCredentials" />
		
		<!-- confirm they are going to be refreshed -->
		<echo><![CDATA[
You are about to refresh from
${retrieve.username}
${retrieve.serverurl}
]]></echo>
		<antcall target="pauseContinue" />
		
		<!-- create a package list of everything for now -->
		<echo file="${profile.packageList.path}" />
		<antcall target="makePackageList">
			<!--
			<param name="includePattern" value="**/*.cls" />
			<param name="excludePattern" value="**/IC_Calendar*" />
			-->
			<param name="packageList.path" value="${profile.packageList.path}" />
		</antcall>
		
		<!-- create a packageList from that path -->
		<mm:SFDC_NewPackageFromFileList
			version="${SFDC_VERSION}"
			chatty="false"
			ignoreUnknownTypes="true"
			fileList="${profile.packageList.path}"
			target="${tmp.file.path}"
		/>
		
		<antcall target="heapWarning" />
		
		<delete dir="${profile.checkout.path}" />
		<mkdir dir="${profile.checkout.path}" />
		
		<echo><![CDATA[
Refreshing...
]]></echo>
		
		<sf:retrieve username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}"
			retrieveTarget="${profile.checkout.path}" unpackaged="${tmp.file.path}"
		/>
		
		<delete dir="${objects.path}" />
		<copy todir="${objects.path}">
			<fileset dir="${profile.checkout.path}/${objects.dir}" />
		</copy>
		
		<delete dir="${profiles.path}" />
		<copy todir="${profiles.path}">
			<fileset dir="${profile.checkout.path}/${profiles.dir}" />
		</copy>
		
		<delete dir="${permissionSets.path}" />
		<copy todir="${permissionSets.path}">
			<fileset dir="${profile.checkout.path}/${permissionSets.dir}" />
		</copy>
		
		<!-- FIX BAD METADATA -->
		<echo>Fixing bad metadata</echo>
		<exec executable="/bin/bash" dir=".">
			<arg value="-c" />
			<arg value="perl -0777 -pi -e 's/&lt;userPermissions&gt;[^&lt;]+&lt;enabled&gt;[^&lt;]+&lt;\/enabled&gt;[^&lt;]+&lt;name&gt;SubscribeToLightningReports&lt;\/name&gt;[^&lt;]+&lt;\/userPermissions&gt;[^&lt;]+//gi' ${src.path}/profiles/*.profile" />
		</exec>
		
		<exec executable="/bin/bash" dir=".">
			<arg value="-c" />
			<arg value="perl -0777 -pi -e 's/(&lt;values&gt;[^&lt;]+&lt;fullName&gt;[^&lt;]+&lt;\/fullName&gt;[^&lt;]+&lt;default&gt;[^&lt;]+&lt;\/default&gt;[^&lt;]+&lt;\/values&gt;)[^&lt;]+\1/$1/gi' ${src.path}/objects/*.object" />
		</exec>
		
		<delete dir="${profile.checkout.path}" />
	</target>
	
	
	
	<!-- 
	/**
	 *  Creates a package from a file list for Testing Purposes.
	 *  
	 *  <p>Nothing is done with the list</p>
	**/
	  -->
	<target name="createFileListPackage"
	>
		<antcallback target="requestFileList" return="fileList.path,fileList" />
		
		<mm:SFDC_NewPackageFromFileList
			version="${SFDC_VERSION}"
			chatty="false"
			fileList="${fileList.path}"
			target="${tmp.file.path}"
		/>
		
		<echo><![CDATA[
Package created at ${tmp.file.path}
]]></echo>
	</target>
	
	
	
	<!-- 
	/**
	 *  Refreshes only the files from a deployment list.
	**/
	  -->
	<target name="refreshFromList"
		description="Refreshes files from a deployment list."
	>
		<antcall target="validateRetrieveCredentials" />
		
		<echo><![CDATA[
You are about to refresh from
${retrieve.username}
${retrieve.serverurl}
]]></echo>
		<antcall target="pauseContinue" />
		
		
		<antcallback target="requestFileList" return="fileList.path,fileList" />
		
		<mm:SFDC_NewPackageFromFileList
			version="${SFDC_VERSION}"
			chatty="false"
			fileList="${fileList.path}"
			target="${tmp.file.path}"
		/>
		
		<antcall target="heapWarning" />
		
		<echo><![CDATA[
Refreshing...
]]></echo>
		<sf:retrieve username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}"
			retrieveTarget="${src.path}" unpackaged="${tmp.file.path}"
		/>
		
		<!-- attempt to revert package.xml -->
		<trycatch>
			<try>
				<move file="${force.package.path}" tofile="${lastRefreshPackage.path}" />
				<exec executable="git" dir="${src.path}">
					<arg value="checkout" />
					<arg value="${force.package.file}" />
				</exec>
			</try>
			<catch>
				<echo>OS refused reverting the force.com package.</echo>
			</catch>
		</trycatch>
		
		<antcall target="extractResources">
			<param name="fileList.path" value="${fileList.path}" />
			<param name="fileList" value="fileList" />
		</antcall>
		
	</target>
	<!-- synonyms -->
	<target name="retrieveFromList" depends="refreshFromList" />
	
	
	
	
	<!-- 
	/**
	 *  Uses the deploymentList to create a package for deployment.
	 *  <p>Note: this does not immediately deploy as we should verify before deploying</p>
	 *  @see deploy
	**/
	 -->
	<target name="deployFromList" description="Creates a deployment from a deployment list">
		<antcall target="copyDeployFromList" />
		
		<antcall target="pauseContinue">
			<param name="continueMsg" value="Would you like to deploy now?" />
		</antcall>
		
		<antcall target="deploy" inheritall="true" >
			<param name="overrideContinue" value="y" />
		</antcall>
	</target>
	<target name="deployFromPackageList" depends="deployFromList" />
	
	
	
	<target name="copyDeployFromList">
		<available file="${deploy.path}" type="dir" property="deploy.exists" />
		<if>
			<and>
				<not><equals arg1="${deploy.exists}" arg2="$${deploy.exists}" /></not>
				<not><equals arg1="${shouldConfirmCopy}" arg2="n" /></not>
			</and>
			<then>
				<echo>Deployment already exists.</echo>
				<antcall target="pauseContinue" />
			</then>
		</if>
		
		<antcall target="cleanDeploy" />
		
		
		<antcallback target="requestFileList" return="fileList.path,fileList">
			<param name="defaultList" value="${recent.list}" />
		</antcallback>
		
		<echo>fileList[${fileList}]</echo>
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.properties" />
			<param name="property.name" value="recent.list" />
			<param name="property.value" value="${fileList}" />
		</antcall>
		
		<if>
			<and>
				<not><equals arg1="${compressResources}" arg2="false" /></not>
			</and>
			<then>
				<antcall target="compressResources">
					<param name="fileList.path" value="${fileList.path}" />
					<param name="fileList" value="fileList" />
				</antcall>
			</then>
		</if>
		
		<mm:SFDC_CopyFilesToPackage
			version="${SFDC_VERSION}"
			chatty="false"
			listFile="${fileList.path}"
			ignoreFile="${ignore.path}"
			sourceDir="${src.path}"
			optionalSourceOffset="force/src"
			packageDir="${deploy.path}"
		/>
	</target>
	
	
	
	<!--
	AutoDeployment using a manual range of commits
	-->
	<target name="autoDeployManual"
		description="AutoDeployment using a manual range of commits"
	>
		<propertycopy name="last.autodeploy.default" from="autodeploy.${force.deploy.environment}" />
		<echo><![CDATA[
What is the starting commit Id?
(Default captured as last autodeploy for ${force.deploy.environment})]]></echo>
		<input addproperty="last.autodeploy" defaultvalue="${last.autodeploy.default}" />
		<if>
			<equals arg1="${last.autodeploy}" arg2="" />
			<then>
				<var name="last.autodeploy" unset="true" />
			</then>
		</if>
		
		<exec executable="git" dir="${src.path}" outputproperty="end.autodeploy.default">
			<arg line="log --pretty=format:'%H' -n 1" />
		</exec>
		<echo><![CDATA[
What is the ending commit id?
(Default is head commit)]]></echo>
		<input addproperty="end.autodeploy" defaultvalue="${end.autodeploy.default}" />
		<if>
			<equals arg1="${end.autodeploy}" arg2="" />
			<then>
				<var name="end.autodeploy" unset="true" />
			</then>
		</if>
		
		<!-- let the autodeploy include pauses -->
		<property name="autoDeploy.isManual" value="y" />
		
		<antcall target="autoDeploy" inheritall="true" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Creates a profile deploy.  Specifically a deploy that ONLY has profile
	 *  information for those things to be deployed.
	 *  @see deploy
	**/
	 -->
	<target name="autoDeploy" description="Creates a deployment from a deployment list">
		<!-- don't pause to ask the user on whether to continue -->
		<property name="overrideContinue" value="y" />
		
		<trycatch>
			<try>
				<if>
					<or>
						<equals arg1="${last.autodeploy}" arg2="$${last.autodeploy}" />
						<equals arg1="${last.autodeploy}" arg2="" />
					</or>
					<then>
						<propertycopy name="last.autodeploy" from="autodeploy.${force.deploy.environment}" />
					</then>
				</if>
			</try>
			<catch>
				<mm:Halt><![CDATA[
It does not appear an autodeploy start commit was specified.

This was expected either by sending
-Dlast.autodeploy=[[SHA]]

or running the following to preserve for future calls
ant lastAutoDeploy -Dlast.autodeploy=[[SHA]]

Please review ant try again ]]></mm:Halt>
			</catch>
		</trycatch>
		
		<!-- end revision to use -->
		<exec executable="git" dir="${src.path}" outputproperty="end.autodeploy">
			<arg line="log --pretty=format:'%H' -n 1" />
		</exec>
		
		<echo><![CDATA[
To call this automatically, simply call the following
ant autoDeploy -Dlast.autodeploy=${last.autodeploy} -Dend.autodeploy=${end.autodeploy}
]]></echo>
		
		<echo><![CDATA[
Creating package from [${last.autodeploy}] to [${end.autodeploy}]

-    -    -    -    -    -    -    -    -    -    -    -    -    -
To manually specify the start SHA, simply include the parameter
-Dlast.autodeploy=[[SHA]]

or running the following to preserve for future calls
ant lastAutoDeploy -Dlast.autodeploy=[[SHA]]

To manually specify the end SHA, simply include the parameter
-Dend.autodeploy=[[SHA]]
-    -    -    -    -    -    -    -    -    -    -    -    -    -

]]></echo>
		
		<property name="auto.filePackage" value="auto.txt" />
		<antcall target="createRevisionList" inheritall="true">
			<param name="revisionStart" value="${last.autodeploy}" />
			<param name="revisionEnd" value="${end.autodeploy}" />
			<param name="filePackage.file" value="${auto.filePackage}" />
		</antcall>
		
		<!-- copy items from deployFromList -->
		<antcall target="cleanDeploy" />
		
		<var name="fileList.path" unset="true" />
		<property name="fileList.path" value="${packageLists.path}/${auto.filePackage}" />
		
		<mm:SFDC_CopyFilesToPackage
			version="${SFDC_VERSION}"
			chatty="false"
			listFile="${fileList.path}"
			ignoreFile="${ignore.path}"
			sourceDir="${src.path}"
			optionalSourceOffset="force/src"
			ignoreMissingFiles="true"
			packageDir="${deploy.path}"
		/>
		
		<loadfile srcfile="${fileList.path}" property='fileList.contents' />
		<condition property="deployProfiles">
			<matches pattern="(^|${n})\s*${profiles.meta}/" string="${fileList.contents}" />
		</condition>
		
		<!--
		Because packages are such a unique structure,
		they must match exactly what is submitted.
		
		For now, do a retrieve for the sole purpose of getting
		a working profile set
		-->
		<echo><![CDATA[
Retrieving profiles from ${retrieve.username}
...
		]]></echo>
		<if>
			<or>
				<equals arg1="${autodeploy.profiles}" arg2="n" />
				<equals arg1="${autodeploy.profiles}" arg2="no" />
				<equals arg1="${autodeploy.profiles}" arg2="false" />
			</or>
			<then>
				<delete dir='${deploy.profiles.path}' />
				
				<mm:SFDC_RemovePackageType sourceFile="${deploy.package.path}" targetFile="${deploy.package.path}"
					metadataType="${profiles.meta}"
					isChatty="false"
				/>
			</then>
			<elseif>
				<not><equals arg1="${deployProfiles}" arg2="$${deployProfiles}" /></not>
				<then>
					<antcall target="refreshDeployProfiles" inheritall="true" />
				</then>
			</elseif>
		</if>
		
		<!-- fix stupid deployment issues from Metadata API -->
		<antcall target="fixMetadataAPI_Nonsense" />
		
		<!-- if running as a manual autoDeploy, allow for pausing prior to the deploy -->
		<if>
			<not><equals arg1="${autoDeploy.isManual}" arg2="$${autoDeploy.isManual}" /></not>
			<then>
				<echo><![CDATA[
Deployment has been created and placed in ${deploy.path}

As stated before, but stated here for convenience,
you can re-run this exact deploy
without prompts or seeing this message by calling:

ant autoDeploy -Dlast.autodeploy=${last.autodeploy} -Dend.autodeploy=${end.autodeploy}

--

As always, you can add to an 'ignore.txt' packageList
and those files will not be deployed if run again.

Conversely, you can adjust the deployment folder
and re-run the following to refresh profiles
(such as to ensure that they only include items specified)

ant refreshDeployProfiles

--

Would you like to proceed with the current deployment?
]]></echo>
				<input addproperty="autodeploy.manContinue1" validargs="y,n" defaultvalue="y" />
				<if>
					<equals arg1="${autodeploy.manContinue1}" arg2="n" />
					<then>
						<mm:Halt>${abort.user}</mm:Halt>
					</then>
				</if>
			</then>
		</if>
		
		<antcall target="deploy" >
		</antcall>
		
		<!-- revert the static resource files from the autodeploy as they shouldn't be recompiled for now -->
		<exec executable="git" dir="${src.path}">
			<arg value="checkout" />
			<arg value="${staticresources.dir}/*" />
		</exec>
		
		<!-- for now, don't update the last autodeploy until rolling changes can be introduced -->
		<if>
			<equals arg1="${autodeploy.autoLatestCommit}" arg2="true" />
			<then>
				<antcall target="lastAutoDeploy" inheritall="true">
					<param name="latestCommit" value="${end.autodeploy}" />
				</antcall>
			</then>
		</if>
		
		<!-- get list of commits included -->
		<exec executable="git" dir="${src.path}" outputproperty="git.log">
			<arg line="log --no-merges --pretty=oneline ${last.autodeploy}...${end.autodeploy}" />
		</exec>
		
		<!-- archive the deployment -->
		<property name="archive.name" value="auto_${timestamp.numeric}" />
		<antcall target="archiveDeploy">
			<param name="deploy.zip.name" value="${archive.name}" />
		</antcall>
		
		<echo file="${deploy.path}/autodeploy.txt"><![CDATA[
Autodeploy

source branch: ${force.retrieve.environment}
target branch: ${force.deploy.environment}
from SHA: ${last.autodeploy}
to SHA: ${end.autodeploy}

List of commits included:
${git.log}
]]></echo>
		
		<!-- add a note to the autodeploy log -->
		<echo file="build.autodeploy" append="true" ><![CDATA[
#autodeploy completed - branch: ${force.retrieve.environment} target: ${force.deploy.environment} from: ${last.autodeploy} to: ${end.autodeploy}]]></echo>

		<!-- give the success message -->
		<echo><![CDATA[

SUCCESS!

branch: ${force.environment}
from: ${last.autodeploy}
to: ${end.autodeploy}

List of commits included:
${git.log}

archived to: ${archive.name}
]]></echo>
	</target>
	
	
	
	<!--
	refreshes the profiles in a deploy
	-->
	<target name="refreshDeployProfiles">
		<!--
		Because packages are such a unique structure,
		they must match exactly what is submitted.
		
		For now, do a retrieve for the sole purpose of getting
		a working profile set
		-->
		<echo><![CDATA[
Retrieving profiles in deploy from ${retrieve.username}
...
		]]></echo>
		<delete dir="${tmp.deploy.path}" />
		<mkdir dir="${tmp.deploy.path}" />
		
		<copy overwrite="true" file='${deploy.package.path}' tofile="${tmp.deploy.package.path}" />
		
		<condition property='includesActivites'>
			<or>
				<resourcecontains resource='${tmp.deploy.package.path}' substring="&lt;members&gt;Task&lt;/members&gt;" />
				<resourcecontains resource='${tmp.deploy.package.path}' substring="&lt;members&gt;Event&lt;/members&gt;" />
			</or>
		</condition>
		
		<if>
			<equals arg1='${includesActivites}' arg2='true' />
			<then>
				<echo>Adding package member</echo>
				<mm:SFDC_AddPackageMember sourceFile="${tmp.deploy.package.path}" targetFile="${tmp.deploy.package.path}"
					metadataType="CustomObject" member="Activity"
					isChatty="false"
				/>
			</then>
		</if>
		
		<!-- <mm:Halt>includesActivites[${includesActivites}]</mm:Halt>-->
		
		<sf:retrieve username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}"
			retrieveTarget="${tmp.deploy.path}" unpackaged="${tmp.deploy.package.path}"
		/>
		
		<delete dir="${deploy.profiles.path}" />
		<mkdir dir="${deploy.profiles.path}" />
		<copy overwrite="true" todir="${deploy.profiles.path}">
			<fileset dir="${tmp.profiles.path}" />
		</copy>
	</target>
	
	
	
	<!--
	Archives the current deploy folder
	-->
	<target name="archiveDeploy"
		description="Archives the current deployment folder"
	>
		<property name="deploy.zip.name.default" value="deploy_${timestamp.numeric}" />
		<echo><![CDATA[
What do you want the archived deployment to be called?
(default: ${deploy.zip.name.default})
]]></echo>
		<input addproperty="deploy.zip.name" />
		<if>
			<equals arg1="${deploy.zip.name}" arg2="" />
			<then>
				<var name="deploy.zip.name" unset="true" />
				<property name="deploy.zip.name" value="${deploy.zip.name.default}" />
			</then>
		</if>
		<property name="deploy.zip.path" value="${deploy.zip.name}.zip" />
		<zip destfile="${deploy.zip.path}">
			<fileset dir="${deploy.path}" includes="**/*.*" />
		</zip>
	</target>
	
	
	
	<target name="lastAutoDeploy">
		<exec executable="git" dir="${src.path}" outputproperty="head.revision">
			<arg line="log --pretty=format:'%H' -n 1" />
		</exec>
		<trycatch>
			<try>
				<if>
					<or>
						<equals arg1="${last.autodeploy}" arg2="$${last.autodeploy}" />
						<equals arg1="${last.autodeploy}" arg2="" />
					</or>
					<then>
						<propertycopy name="last.autodeploy" from="autodeploy.${force.deploy.environment}" />
					</then>
				</if>
			</try>
			<catch>
				<property name="last.autodeploy" value="" />
			</catch>
		</trycatch>
		
		<echo><![CDATA[
What is the starting point for the next autoDeploy on ${force.deploy.environment}?
]]></echo>
		<input addproperty="latestCommit" defaultvalue="${last.autodeploy}" />
		<if>
			<equals arg1="${latestCommit}" arg2="" />
			<then>
				<var name="latestCommit" unset="true" />
				<property name="latestCommit" value="${head.revision}" />
			</then>
		</if>
		
		<property name="commitProperty" value="autodeploy.${force.deploy.environment}" />
		<replaceregexp  encoding="UTF-8" file="build.autodeploy"
			match="(^|${n})([ \t]*${commitProperty}.+)"
			replace="\1#\2"
			flags="img"
		/>
		<echo file="build.autodeploy" append="true"><![CDATA[
${commitProperty}=${latestCommit}]]></echo>
	</target>
	
	
	
	<target name="fixMetadataAPI_Nonsense">
		<!-- handle rather stupid things about what and how things are migrated -->
		<!-- You may not modify the permission Create and Customize Reports while editing a Standard Profile -->
		<trycatch>
			<try>
				<replaceregexp encoding="UTF-8" flags="img"
					match="&lt;userPermissions&gt;\s*(&lt;enabled&gt;[^\n&lt;]+&lt;/enabled&gt;\s*|&lt;name&gt;\s*CreateCustomizeReports\s*&lt;/name&gt;\s*)+&lt;/userPermissions&gt;\s*"
					replace=""
				>
					<fileset dir="${deploy.path}" includes="**/*.profile"/>
				</replaceregexp>
			</try>
			<catch></catch>
		</trycatch>
		
		<!-- Invalid Push Notifications: -->
		<trycatch>
			<try>
				<replaceregexp encoding="UTF-8" flags="img"
					match="&lt;\s*pushNotifications\s*&gt;"
					replace="†"
				>
					<fileset dir="${deploy.path}/applications" includes="**/*.app"/>
				</replaceregexp>
				<replaceregexp encoding="UTF-8" flags="img"
					match="&lt;\s*/\s*pushNotifications&gt;"
					replace="‡"
				>
					<fileset dir="${deploy.path}/applications" includes="**/*.app"/>
				</replaceregexp>
				<replaceregexp encoding="UTF-8" flags="img"
					match="†[^†‡]+‡\s*"
					replace=""
				>
					<fileset dir="${deploy.path}/applications" includes="**/*.app"/>
				</replaceregexp>
			</try>
			<catch></catch>
		</trycatch>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds multiple resources to the deployment
	**/
	 -->
	<target name="addResourcesToDeploy" description="Adds multiple resources to the deployment"
	>
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${staticresources.path}" />
			<param name="file.match" value="*.resource" />
			<param name="remove.extension" value="[.]resource" />
		</antcallback>
		
		<echo>What is the name of the resource?
		
${file.list}</echo>
		
		<input addproperty="resource.bases" />
		
		<foreach list="${resource.bases}"
			target="addResourceToDeploy"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	Template targets
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	<!-- 
	/**
	 *  Creates metadata/files based on templates.
	 *  (Such as Static Resources/Classes/Triggers/etc)
	 *  
	 *  <p>To create additional templates, create a new file in:
	 *  ${meta.path}/${filePackage.dir}.template</p>
	 *  
	 *  <p>The string of ##FILENAME## will be replaced with the name of the file being asked.</p>
	 *  
	 *  <p>Include ${meta.path}/${filePackage.dir}.meta.template if a meta file is needed.</p>
	**/
	 -->
	<target name="new" depends="template" />
	<target name="template"
		description="Creates metadata/files based on templates"
	>
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${meta.path}" />
			<param name="file.match" value="*.template" />
			<param name="file.exclude" value="*.meta.template" />
			<param name="remove.extension" value="[.]template" />
		</antcallback>
		
		<echo><![CDATA[
What type of file should we create?
]]></echo>
		<input addproperty="filePackage.dir" validargs="${file.list}" />
		
		<echo><![CDATA[
What name do you want for your ${filePackage.dir} file?
]]></echo>
		<input addproperty="fileName" />
		<if><or>
			<equals arg1="${fileName}" arg2="$${fileName}" />
			<equals arg1="${fileName}" arg2="" />
		</or>
		<then>
			<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
		</then></if>
		
		<propertyregex property="fileName"
			input="${fileName}"
			override="true"
			regexp="[.].+$"
			replace=""
		/>
		
		<mm:SFDC_ConvertFolderToExtension folderName="${filePackage.dir}" targetProperty="fileExtension" />
		<property name="target.file" value="${fileName}${fileExtension}" />
		<property name="target.path" value="${src.path}/${filePackage.dir}/${target.file}" />
		<property name="source.path" value="${meta.path}/${filePackage.dir}.template" />
		
		<property name="target.meta.path" value="${src.path}/${filePackage.dir}/${target.file}${meta_suffix}" />
		<property name="source.meta.path" value="${meta.path}/${filePackage.dir}.meta.template" />
		
		<!--
		<echo>
target.path=${target.path}
source.path=${source.path}

target.meta.path=${target.meta.path}
source.meta.path=${source.meta.path}
</echo>
		-->
		
		<copy file="${source.path}" tofile="${target.path}" />
		
		<replaceregexp encoding="UTF-8" file="${target.path}"
			match="##VERSION##"
			replace="${SFDC_VERSION}"
			flags="img"
		/>
		<replaceregexp encoding="UTF-8" file="${target.path}"
			match="##FILENAME##"
			replace="${fileName}"
			flags="img"
		/>

		<trycatch>
			<try>
				<copy file="${source.meta.path}" tofile="${target.meta.path}" />
				
				<replaceregexp encoding="UTF-8" file="${target.meta.path}"
					match="##VERSION##"
					replace="${SFDC_VERSION}"
					flags="img"
				/>
				<replaceregexp encoding="UTF-8" file="${target.meta.path}"
					match="##FILENAME##"
					replace="${fileName}"
					flags="img"
				/>
			</try>
			<catch>
			</catch>
		</trycatch>
		
		
		<!-- add a translation if creating a static resource through template -->
		<if>
			<or>
				<equals arg1="${filePackage.dir}" arg2="${staticresources.dir}" />
			</or>
			<then>
				<antcall target="addResourceTranslation" inheritall="true">
					<param name="resource.name" value="${fileName}" />
				</antcall>
			</then>
		</if>
		
		<!-- Check to add to a package list -->
		<echo><![CDATA[
Would you like to add to a packageList?
]]></echo>
		<input addproperty="addPackageList"
			validargs="y,n"
			defaultvalue="y"
		/>
		<if>
			<equals arg1="${addPackageList}" arg2="y" />
			<then>
				<antcallback target="getDirectoryFiles" return="file.list">
					<param name="source.dir" value="${packageLists.path}" />
					<param name="file.match" value="*.txt" />
					<param name="remove.extension" value="[.]txt" />
				</antcallback>
				
				<echo><![CDATA[
Which file list should we add it to?
${file.list}
]]></echo>
				<input addproperty="packageList.name" />
				<property name="packageList.path" value="${packageLists.path}/${packageList.name}.txt" />
				
				<echo file="${packageList.path}" append="true"><![CDATA[
${filePackage.dir}/${target.file}]]></echo>
				
				<echo><![CDATA[
Successfully updated ${packageList.path}
]]></echo>
			</then>
		</if>
		
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	Manage deploy folders
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!-- 
	/**
	 *  Shelves the deploy folder so it can be used at a later time.
	**/
	 -->
	<target name="shelveDeploy"
		description="Shelves the deploy folder so it can be used at a later time"
	>
		<available file="deploy" type="dir" property="deploy.exists" />
		<if>
			<equals arg1="${deploy.exists}" arg2="$${deploy.exists}" />
			<then>
				<echo>Deployment folder doesn't exist yet. Try running deployFromFileList.</echo>
				<mm:Halt msg="Deployment folder doesn't exist yet. Try running deployFromFileList." />
				
			</then>
		</if>
		
		<antcallback target="getDirList" return="dir.list">
			<param name="base.dir" value="." />
			<param name="dir.filter" value="deploy_*" />
		</antcallback>
		
		<propertyregex property="dir.list2"
			input="${dir.list}"
			regexp="\bdeploy_"
			replace=""
			global="true"
		/>
		
		<echo>What should it be changed to?
Existing shelves: ${dir.list2}</echo>
		<input addproperty="deploy.target" />
		<property name="deploy.target2" value="deploy_${deploy.target}" />
		
		<move file="deploy" tofile="${deploy.target2}" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  loads a shelved deploy folder.
	**/
	 -->
	<target name="loadDeploy"
		description="Shelves the deploy folder so it can be used at a later time"
	>
		<available file="deploy" type="dir" property="deploy.exists" />
		<if>
			<not><equals arg1="${deploy.exists}" arg2="$${deploy.exists}" /></not>
			<then>
				<echo>Deploy already exists</echo>
				<antcall target="pauseContinue" />
			</then>
		</if>
		
		<antcallback target="getDirList" return="dir.list">
			<param name="base.dir" value="." />
			<param name="dir.filter" value="deploy_*" />
		</antcallback>
		<echo>Which deploy folder?</echo>
		<propertyregex property="dir.list2"
			input="${dir.list}"
			regexp="\bdeploy_"
			replace=""
			global="true"
		/>
		<input addproperty="deploy.source" validargs="${dir.list2}" />
		
		<move file="deploy_${deploy.source}" tofile="deploy" />
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	Package List Targets
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	<!--
	/**
	 *  Lists the contents of a package list
	**/
	-->
	<target name="showPackageList"
		description="Lists the contents of a package list"
	>
		<antcallback target="whichPackageList" return="packageList.path" />
		
		<antcall target="showPackageList_internal" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Creates a package list for all files that are currently held in the src directory
	 *  @deprecated - shortcut for addToPackageList with the value of * provided for the filter.
	**/
	 -->
	<target name="makePackageListAll"
		description="Creates a package list for all files currently held in the src directory. *see addToPackageList"
	>
		<echo file="${all.packageList.path}" />
		<antcall target="makePackageList">
			<!--
			<param name="includePattern" value="**/*.cls" />
			<param name="excludePattern" value="**/IC_Calendar*" />
			-->
			<param name="packageList.path" value="${all.packageList.path}" />
		</antcall>
		
		<echo>

Success.

PackageList "all" updated under ${all.packageList.path}</echo>
	</target>
	
	<!-- synonyms -->
	<target name="createAllList" depends="makePackageListAll" />
	
	<target name="makePackageListAll_forloop">
		<var name="folder" unset="true" />
		<mm:SFDC_ConvertMetadataToFolder metadata="${metadata.type}" targetProperty="folder" />
		<echo>[${metadata.type}][${folder}]</echo>
		<replaceregexp encoding="UTF-8" file="${all.packageList.path}"
			match="/src/${metadata.type}/"
			replace="/src/${folder}/"
			flags="img"
		/>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds files to a package list using a pattern
	**/
	 -->
	<target name="addToPackageListPattern">
		<antcallback target="whichPackageList" return="packageList.path" />
		
		<echo><![CDATA[
What types of files should be added?
(Uses Java filename patterns)

For example,
All classes:
*.cls

All classes that start with SOS:
SOS_*.cls

All files that start with SOS (triggers,classes,objects,etc)
SOS_*

etc.
]]></echo>
		<input addproperty="includePattern.in" />
		<property name="includePattern" value="**/${includePattern.in}" />
		
		<antcall target="makePackageList">
			<param name="includePattern" value="${includePattern}" />
			<param name="packageList.path" value="${packageList.path}" />
		</antcall>
		
		<antcall target="showPackageList_internal">
			<param name="packageList.path" value="${packageList.path}" />
		</antcall>
		<echo><![CDATA[

Successfully updated: ${packageList.path}]]></echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds files to a package list using a metadata search pattern
	**/
	 -->
	<target name="addToPackageListSearch">
		<antcallback target="whichPackageList" return="packageList.path" />
		
		<echo>From the following list of metadata types:</echo>
		<antcall target="listMetadataTypesInternal" />
		
		<echo>Which metadata type would you like to add to the package?
(Note: Salesforce api is case sensitive)
</echo>

		<input
			addproperty="metadata.type"
		/>
		
		<if>
			<or>
				<equals arg1="${metadata.type}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<property name="addPackageMember.toList" value="y" />
		
		<foreach list="${metadata.type}"
			target="addPackageTypeInternal"
			param="metadata.type"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<antcall target="showPackageList_internal">
			<param name="packageList.path" value="${packageList.path}" />
		</antcall>
		<echo><![CDATA[

Successfully updated: ${packageList.path}]]></echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds files to a package list selecting from a list
	**/
	 -->
	<target name="addToPackageListSelect">
		<antcallback target="whichPackageList" return="packageList.path" />
		
		<antcallback target="getDirList" return="dir.list">
			<param name="base.dir" value="${src.path}" />
		</antcallback>
		
		<echo><![CDATA[

Which directory?]]></echo>
		<input addproperty="filePackage.dir" validargs="${dir.list}" />
		
		<antcallback target="getFileList" return="file.list">
			<param name="base.dir" value="${src.path}/${filePackage.dir}" />
		</antcallback>
		
		<echo><![CDATA[

Which file?
(Please include extension)
]]></echo>
		<input addproperty="filePackage.file" validargs="${file.list}" />
		
		<echo file="${packageList.path}" append="true"><![CDATA[
${filePackage.dir}/${filePackage.file}
]]></echo>
		
		<antcall target="showPackageList_internal">
			<param name="packageList.path" value="${packageList.path}" />
		</antcall>
		<echo><![CDATA[

Successfully updated: ${packageList.path}]]></echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds files to a package list selecting from a list
	**/
	 -->
	<target name="addToPackageListManual">
		<antcallback target="whichPackageList" return="packageList.path" />
		
		<antcallback target="getDirList" return="dir.list">
			<param name="base.dir" value="${src.path}" />
		</antcallback>
		
		<echo><![CDATA[
List of known directories:
${dir.list}

Which directory?
]]></echo>
		<input addproperty="filePackage.dir" />
		
		<mm:SFDC_ConvertFolderToExtension folderName="${filePackage.dir}" targetProperty="file.extension" />
		
		<!--
		<antcallback target="getFileList" return="file.list">
			<param name="base.dir" value="${src.path}/${filePackage.dir}" />
		</antcallback>
		
		<propertyregex property="file.list"
			input="${file.list}"
			override="true"
			regexp="\s*,"
			replace="     ,"
		/>
		list of known files: ${file.list}
		-->
		<echo><![CDATA[

Which file?
]]></echo>
		<if>
			<or>
				<equals arg1="${file.extension}" arg2="$${file.extension}" />
				<equals arg1="${file.extension}" arg2="" />
			</or>
			<then>
				<echo><![CDATA[(Unknown extension. Please include extension)
]]></echo>
			</then>
			<else>
				<echo><![CDATA[(Extension automatically included: ${file.extension})
]]></echo>
			</else>
		</if>
		<input addproperty="filePackage.file" />
		
		<!-- remove the extension if it was provided -->
		<propertyregex property="filePackage.file"
			input="${filePackage.file}"
			override="true"
			regexp="${file.extension}$"
			replace=""
		/>
		
		<echo file="${packageList.path}" append="true"><![CDATA[
${filePackage.dir}/${filePackage.file}${file.extension}
]]></echo>
		
		<antcall target="showPackageList_internal">
			<param name="packageList.path" value="${packageList.path}" />
		</antcall>
		<echo><![CDATA[

Successfully updated: ${packageList.path}]]></echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Removes a package list.
	**/
	 -->
	<target name="removePackageList"
		description="Deletes a package list"
	>
		<antcallback target="requestFileList" return="fileList.path" />
		
		<delete file="${fileList.path}" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Lists out a specific package list
	**/
	 -->
	<target name="listPackageList"
		description="Provides the files in a specific packageList"
	>
		<antcallback target="requestFileList" return="fileList.path" />
		<echo>${fileList.path}</echo>
		
		<loadfile srcfile="${fileList.path}" property="packageList.contents" />
		<echo><![CDATA[
${packageList.contents}

${fileList.path}]]></echo>
	</target>
	
	
	
	
	<!-- 
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	SETTINGS TARGETS
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	-->
	
	
	
	
	<!--
	/**
	 * Changes whether only test deployments occur
	 **/
	-->
	<target name="testDeploy" description="Changes whether only test deployments occur">
		<echo>Should deployments be test deployments only?
(blank to keep current value: ${isTestDeploy})</echo>
		<input
			addproperty="isTestDeployInput"
			validargs="true,false"
			defaultvalue=""
		/>
		
		<if>
			<equals arg1="${isTestDeployInput}" arg2="" />
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.properties" />
			<param name="property.name" value="isTestDeploy" />
			<param name="property.value" value="${isTestDeployInput}" />
		</antcall>
		
		<var name="isTestDeploy" unset="true" />
		<property file="build.properties" />
		<echo>
	#whether deployments are only tested
	isTestDeploy=${isTestDeploy}
		</echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Defines the default environment to use
	**/
	 -->
	<target name="setupEnvironment"
		description="Defines credentials for a specific environment"
	>
		<echo><![CDATA[
Which environment should we set as the default retrieve/deploy environment?
(Leave blank to allow the current git branch repository to be the default
see readme for details)

${valid.environments}
]]></echo>
		
		<input addproperty="environment.in" />
		<if>
			<or>
				<equals arg1="${environment.in}" arg2="" />
			</or>
			<then>
				<replaceregexp encoding="UTF-8" file="build.properties"
					match="${n}[ \t]*force.environment=" replace="${n}#force.environment="
				/>
			</then>
			<else>
				<replaceregexp encoding="UTF-8" file="build.properties"
					match="(#\s*)?force.environment=.*"
					replace="force.environment=${environment.in}"
				/>
			</else>
		</if>
		
		<!-- disable the overrides for the other environments -->
		<replaceregexp encoding="UTF-8" file="build.properties"
			match="${n}[ \t]*force.retrieve.environment=" replace="${n}#force.retrieve.environment="
		/>
		<replaceregexp encoding="UTF-8" file="build.properties"
			match="${n}[ \t]*force.deploy.environment=" replace="${n}#force.deploy.environment="
		/>
		
		<var name="force.environment" unset="true" />
		<var name="force.retrieve.environment" unset="true" />
		<var name="force.deploy.environment" unset="true" />
		
		<property file="build.properties" />
		
		<antcallback target="checkCredentials" inheritall="true">
			<param name="ignore" value="credentials" />
		</antcallback>
		
		<echo><![CDATA[

Please run
ant status
to see the latest values.
]]></echo>
		
	</target>
	
	
	
	<!--
	Allows the user to reset the source credentials
	-->
	<target name="resetCredentials"
		description="Allows resetting the credentials for a specific environment"
	>
		<echo><![CDATA[
Which environment should we change the credentials for?
]]></echo>
		<input addproperty="target.environment" validargs="${valid.environments}" />
		
		<antcall target="setupCredentials" inheritall="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Defines the last commit used when showing repository changes
	**/
	-->
	<target name="lastChangeCommit"
		description="Defines the last commit used when showing repository changes"
	>
		<!-- determine if the property file includes the last commit to check against -->
		<condition property='hasLastCommit'>
			<resourcecontains resource='build.properties' substring="docChanges.lastCommit=" />
		</condition>
		
		<!-- use current head -->
		<exec executable="git" dir="${src.path}" outputproperty="currentCodeHead">
			<arg line="log --pretty=format:'%H' -n 1" />
		</exec>
		
		<if>
			<equals arg1="${hasLastCommit}" arg2="$${hasLastCommit}" />
			<then>
				<echo append="true" file="build.properties"><![CDATA[

## Last commit used when showing the repository changes
docChanges.lastCommit=
]]></echo>
			</then>
		</if>
		
		<echo><![CDATA[
What is the (non-inclusive) commit we should use when documenting recent changes?
(Blank to use HEAD]]></echo>
		
		<input
			addproperty="lastChangeCommit"
			defaultvalue="${currentCodeHead}"
		/>
		
		<if>
			<equals arg1="${lastChangeCommit}" arg2="" />
			<then>
				<var name="lastChangeCommit" unset="true" />
				<property name="lastChangeCommit" value="${currentCodeHead}" />
			</then>
		</if>
		
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.properties" />
			<param name="property.name" value="docChanges.lastCommit" />
			<param name="property.value" value="${lastChangeCommit}" />
		</antcall>
		
		<echo><![CDATA[
Please run
>ant status

to see the current values
]]></echo>
	</target>
		
	
	
	
	<!-- 
	/**
	 *  Defines credentials for a specific environment
	**/
	 -->
	<target name="setupCredentials"
		description="Defines credentials for a specific environment"
	>
		<echo><![CDATA[
What is the username we should use to retrieve for ${target.environment}?
]]></echo>
		<input addproperty="retrieve.username.in" />
		
		<echo>Password</echo>
		<input addproperty="retrieve.password.in" />
		
		<echo>Host</echo>
		<input addproperty="retrieve.host" validargs="test.salesforce,login.salesforce" />
		<property name="retrieve.serverurl.in" value="https://${retrieve.host}.com" />
		
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.credentials" />
			<param name="property.name" value="${target.environment}.username" />
			<param name="property.value" value="${retrieve.username.in}" />
		</antcall>
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.credentials" />
			<param name="property.name" value="${target.environment}.password" />
			<param name="property.value" value="${retrieve.password.in}" />
		</antcall>
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.credentials" />
			<param name="property.name" value="${target.environment}.serverurl" />
			<param name="property.value" value="${retrieve.serverurl.in}" />
		</antcall>
		
		<echo><![CDATA[
Credentials for ${target.environment} setup.
]]></echo>
		
		<!-- @TODO: validate that this is needed -->
		<var name="retrieve.username" unset="true" />
		<var name="retrieve.password" unset="true" />
		<var name="retrieve.serverurl" unset="true" />
		<property name="retrieve.username" value="${retrieve.username.in}" />
		<property name="retrieve.password" value="${retrieve.password.in}" />
		<property name="retrieve.serverurl" value="${retrieve.serverurl.in}" />
	</target>
	
	
	
	<!-- 
	/**
	 *  Defines the credentials used to retrieve metadata.
	**/
	 -->
	<target name="setupRetrieveCredentials"
		description="Defines the credentials used to retrieve metadata"
	>
		<echo><![CDATA[
Which environment should we retrieve from?
(Leave blank to default to the current force environment: ${force.environment} )

${valid.environments}
]]></echo>
		
		<input addproperty="retrieve.environment.in" />
		<if>
			<or>
				<equals arg1="${deploy.retrieve.in}" arg2="" />
				<equals arg1="${deploy.retrieve.in}" arg2="${force.environment}" />
			</or>
			<then>
				<replaceregexp encoding="UTF-8" file="build.properties"
					match="${n}[ \t]*force.retrieve.environment=" replace="${n}#force.retrieve.environment="
				/>
			</then>
			<else>
				<replaceregexp encoding="UTF-8" file="build.properties"
					match="(#\s*)?force.retrieve.environment=.*"
					replace="force.retrieve.environment=${retrieve.environment.in}"
				/>
			</else>
		</if>
		
		<var name="force.retrieve.environment" unset="true" />
		<property file="build.properties" />
		
		<antcallback target="checkCredentials" inheritall="true">
			<param name="ignore" value="credentials" />
		</antcallback>
		
		<echo><![CDATA[

Please run
ant status
to see the latest values.
]]></echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Defines the credentials used to deploy metadata.
	**/
	 -->
	<target name="setupDeployCredentials"
		description="Defines the credentials used to deploy metadata"
	>
		<echo><![CDATA[
Which environment should we deploy to?
(Leave blank to default to the current force environment: ${force.environment} )

${valid.environments}
]]></echo>
		
		<input addproperty="deploy.environment.in" />
		<if>
			<or>
				<equals arg1="${deploy.environment.in}" arg2="" />
				<equals arg1="${deploy.environment.in}" arg2="${force.environment}" />
			</or>
			<then>
				<replaceregexp encoding="UTF-8" file="build.properties"
					match="${n}[ \t]*force.deploy.environment\s*=" replace="${n}#force.deploy.environment="
				/>
			</then>
			<else>
				<replaceregexp encoding="UTF-8" file="build.properties"
					match="${n}[ \t]*(#\s*)?force.deploy.environment\s*=.*" replace="${n}force.deploy.environment=${deploy.environment.in}"
				/>
			</else>
		</if>
		
		<var name="force.deploy.environment" unset="true" />
		<property file="build.properties" />
		
		<antcallback target="checkCredentials" inheritall="true" />
		
		<echo><![CDATA[

Please run
ant status
to see the latest values.
]]></echo>
	</target>
	
	
	
	<!--
	Creates an environment settings file under resources
	so credentials are automatically chosen on git branch selection
	-->
	<target name="createEnvironmentSettings"
		description="Creates an environment settings file"
	>
		<copy file="${environment.settings.template}" tofile="${environment.settings.path}" overwrite="true" />
		
		<echo><![CDATA[
What is the name of this environment?
]]></echo>
		<input addproperty="env.name" />
		<if>
			<equals arg1="${env.name}" arg2="" />
			<then>
				<var name="env.name" unset="true" />
				<property name="env.name" value="${default.environment}" />
			</then>
		</if>
		
		<replaceregexp encoding="UTF-8" file="${environment.settings.path}"
			match="(#\s*)?force.environment=.*"
			replace="force.environment=${env.name}"
		/>
		
		<antcall target="setupEnvironment">
			<param name="environment.in" value="" />
		</antcall>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds a resource translation to the build.xml, to specify the name of the resource
	 *  and the file/folder it should be extracted/compressed to/from.
	**/
	 -->
	<target name="addResourceTranslation">
		<echo><![CDATA[
What is the name of this resource?
(note: this does not need .resource extension)
]]></echo>
		<input addproperty="resource.name" />
		
		<propertyregex property="resource.name"
			override="true"
			input="${resource.name}"
			regexp="[.]resource\s*"
			replace=""
		/>
		
		<echo><![CDATA[
new resource name: ${resource.name}
]]></echo>
		
		<!-- remove any previous translations -->
		<replaceregexp encoding="UTF-8" file="build.properties"
			match="^${resource.name}[.]resource.*" replace=""
			flags="img" 
		/>
		<replaceregexp encoding="UTF-8" file="build.properties"
			match="^${resource.name}[.]file.*" replace=""
			flags="img" 
		/>
		<replaceregexp encoding="UTF-8" file="build.properties"
			match="^${resource.name}[.]zip.*" replace=""
			flags="img" 
		/>
		
		<echo><![CDATA[



Is this resource a zip or a file (such as a js/image/etc)
]]></echo>
		<input addproperty="resource.type" validargs="zip,file" />
		
		<if>
			<equals arg1="${resource.type}" arg2="file" />
			<then>
				<echo>
What is the extension that this file should have?
</echo>
				<input addproperty="resource.extension" />
				
				<propertyregex property="resource.extension"
					override="true"
					input="${resource.extension}"
					regexp="^\s*[.]*"
					replace="."
				/>
				
				<propertyregex property="resource.extension"
					override="true"
					input="${resource.extension}"
					regexp="^\s*[.]\s*$"
					replace=""
				/>
				
				<property name="resource.result" value="${resource.name}${resource.extension}" />
				<echo><![CDATA[
The following has been added to your build.environment file:
${resource.name}.resource=${resource.name}.resource
${resource.name}.file=${resource.result}
				]]></echo>
				
				<echo file="build.environment" append="true"><![CDATA[
${resource.name}.resource=${resource.name}.resource
${resource.name}.file=${resource.result}
]]></echo>
				<property name='resource.path' value='${resources.path}/${resource.result}' />
				<available file='${resource.path}' property='resource.exists' />
				<if>
					<equals arg1='${resource.exists}' arg2='$${resource.exists}' />
					<then>
						<!-- make a file then -->
						<echo file="${resources.path}/${resource.result}"><![CDATA[
Replace this file with your resource
]]></echo>
					</then>
				</if>
			</then>
			<else>
				<property name="resource.result" value="${resource.name}_zip" />
				<echo><![CDATA[
The following has been added to your build.environment file:
${resource.name}.resource=${resource.name}.resource
${resource.name}.zip=${resource.result}
				]]></echo>
				
				<echo file="build.environment" append="true"><![CDATA[
${resource.name}.resource=${resource.name}.resource
${resource.name}.zip=${resource.result}
]]></echo>
				
				<property name="resource.path" value="${resources.path}/${resource.result}" />
				<available file="${resource.path}" property="resource.exists" />
				<if>
					<equals arg1="${resource.exists}" arg2="$${resource.exists}" />
					<then>
						<mkdir dir="${resources.path}/${resource.result}" />
						<echo file="${resources.path}/${resource.result}/test.txt"><![CDATA[
Replace this file with your resource
]]></echo>
					</then>
				</if>
			</else>
		</if>
	</target>
	
	
	
	
	<!--
	Adds a packageList to the current package
	-->
	<target name="applyPackageListToPackage"
		description="Merges the package list into the current package"
	>
		
		<antcallback target="requestFileList" return="fileList.path,fileList">
			<param name="defaultList" value="${recent.list}" />
		</antcallback>
		
		<echo>fileList[${fileList}]</echo>
		<antcall target="changePropertyFileValue">
			<param name="propertyFile.path" value="build.properties" />
			<param name="property.name" value="recent.list" />
			<param name="property.value" value="${fileList}" />
		</antcall>
		
		<mm:SFDC_ApplyFileListToPackage
			chatty="false"
			listFile="${fileList.path}"
			ignoreFile="${ignore.path}"
			package="${force.package.path}"
		/>
		
		
	</target>
	
	
	
	<!--
	Creates a destructive change deployment from a package list
	-->
	<target name="destroyUsingList"
		description="Creates a destructive change deployment from a package list"
	>
		<echo><![CDATA[
This is about to create a destructive change deployment.

Do you wish to continue?]]></echo>
		<input addproperty="shouldContinue1"
			validargs="y,n"
			defaultvalue="n"
		/>
		<if>
			<equals arg1="${shouldContinue1}" arg2="n" />
			<then>
				<mm:Halt>${abort.user}</mm:Halt>
			</then>
		</if>
		
		<antcallback target="requestFileList" return="fileList.path,fileList">
		</antcallback>
		
		<antcall target="cleanDeploy" />
		<mkdir dir="${deploy.path}" />
		
		<echo file="${deploy.package.path}"><![CDATA[<?xml version="1.0" ?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
	<version>${SFDC_VERSION}</version>
</Package>]]></echo>

		<echo file="${deploy.destructive.path}"><![CDATA[<?xml version="1.0" ?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
	<version>${SFDC_VERSION}</version>
</Package>]]></echo>
		
		<mm:SFDC_ApplyFileListToPackage
			chatty="false"
			listFile="${fileList.path}"
			ignoreFile="${ignore.path}"
			package="${deploy.destructive.path}"
		/>
		
				
		<loadfile srcfile="${deploy.destructive.path}" property="packageList.contents" />
		<echo><![CDATA[
${packageList.contents}

${fileList.path}

--


Destructive changes are added to
${deploy.destructive.path}

Modify this file prior to deployment if necessary.
]]></echo>
		
		<antcall target="pauseContinue">
			<param name="continueMsg" value="Would you like to deploy now?" />
		</antcall>
		
		<antcall target="deploy" inheritall="true" >
			<param name="overrideContinue" value="y" />
		</antcall>
		
		<echo><![CDATA[
Would you like to delete locally?
]]></echo>
		<input addproperty="shouldDelete.locally" validargs="y,n" defaultvalue="y" />
		<if>
			<equals arg1="${shouldDelete.locally}" arg2="y" />
			<then>
				<antcall target="deleteUsingList" />
			</then>
		</if>
	</target>
	
	
	
	
	<!--
	Deletes a list of files based on a package list
	-->
	<target name="deleteUsingList"
		description="Deletes a list of files based on a package list"
	>
		<if>
			<or>
			<equals arg1="${fileList.path}" arg2="$${fileList.path}" />
			<equals arg1="${fileList.path}" arg2="" />
			</or>
			<then>
				<var name="fileList.path" unset="true" />
				<antcallback target="requestFileList" return="fileList.path,fileList">
				</antcallback>
			</then>
		</if>
		
		<copy overwrite="true" file="${fileList.path}" tofile="${tmp.file.path}" />
		
		<antcall target="filterFile" inheritall="true" >
			<param name="lineFilter" value="^[ \t]*[^#\n/]+/" />
			<param name="filterTarget" value="${tmp.file.path}" />
		</antcall>
		<replaceregexp encoding="UTF-8" file="${tmp.file.path}"
			match="[ \t]*${n}[ \t]*" replace=","
			flags="img" 
		/>
		<loadfile srcfile="${tmp.file.path}" property="tmp.contents" />
		<foreach list="${tmp.contents}"
			target="removeFile_internal"
			param="fileToDelete.path"
			delimiter=","
			trim="true"
			parallel="false"
		/>
		
		<echo><![CDATA[ ${n}${n}${n}${n}${n}${n}Deletion was successful]]></echo>
	</target>
	
	
	
	
	<!--
	/**
	 *  Removes the files locally using git or delete
	**/
	-->
	<target name="removeFile_internal">
		<echo><![CDATA[
Removing: ${fileToDelete.path}]]></echo>
		
		<property name="fileToDelete.src.path" value="${src.path}/${fileToDelete.path}" />
		<propertyregex property="fileToDelete.src.path"
			input="${fileToDelete.src.path}"
			regexp="[.]aura$"
			replace=""
			override="true" />
		
		<available file="${fileToDelete.src.path}" property="fileToDelete.exists" />
		<if>
			<and>
				<equals arg1="${fileToDelete.exists}" arg2="$${fileToDelete.exists}" />
			</and>
			<then>
				<echo><![CDATA[Unable to find file [${fileToDelete.path}]. Continuing.]]></echo>
			</then>
		</if>
		
		<trycatch>
			<try>
				<delete dir="${fileToDelete.src.path}" />
			</try>
			<catch>
			</catch>
		</trycatch>
		<trycatch>
			<try>
				<delete file="${fileToDelete.src.path}" />
			</try>
			<catch>
				<echo><![CDATA[Unable to delete file [${fileToDelete.path}]]></echo>
			</catch>
		</trycatch>
		<trycatch>
			<try>
				<delete file="${fileToDelete.src.path}${meta_suffix}" />
			</try>
			<catch>
			</catch>
		</trycatch>
	</target>
	
	
	
	
	<!--
	Clears all apex from any classes or triggers in the deployment folder.
	<p>Used for renaming of fields</p>
	-->
	<target name="clearApex"
		description="Clears all apex from any classes or triggers in deploy"
	>
		<antcall target="copyDeployFromList" inheritall="true">
			<param name="shouldConfirmCopy" value="n" />
		</antcall>
		
		<!-- classes -->
		<replaceregexp encoding="UTF-8" byline="true">
			<regexp pattern="\bclass\b"/>
			<substitution expression="†class"/>
			<fileset dir="${deploy.path}">
				<include name="**/*.cls"/>
			</fileset>
		</replaceregexp>
		<replaceregexp encoding="UTF-8" byline="false">
			<regexp pattern="((^|${n})[ \t]*(public|global|private)[^\n{†]+†class[^\n{]*[{])[^∠]+"/>
			<substitution expression="\1}"/>
			<fileset dir="${deploy.path}">
				<include name="**/*.cls"/>
			</fileset>
		</replaceregexp>
		<replaceregexp encoding="UTF-8" byline="true">
			<regexp pattern="†class"/>
			<substitution expression="class"/>
			<fileset dir="${deploy.path}">
				<include name="**/*.cls"/>
			</fileset>
		</replaceregexp>
		
		<!-- triggers -->
		<replaceregexp encoding="UTF-8" byline="true">
			<regexp pattern="^[ \t]*trigger[^\n{]+\{"/>
			<substitution expression="\0∠"/>
			<fileset dir="${deploy.path}">
				<include name="**/*.trigger"/>
			</fileset>
		</replaceregexp>
		<replaceregexp encoding="UTF-8" byline="false">
			<regexp pattern="∠[^∠]*"/>
			<substitution expression="}"/>
			<fileset dir="${deploy.path}">
				<include name="**/*.trigger"/>
			</fileset>
		</replaceregexp>
		
		<!-- pages -->
		<replaceregexp encoding="UTF-8" byline="false">
			<regexp pattern="&lt;\s*apex\s*:\s*page[^∠]+"/>
			<substitution expression="&lt;apex:page /&gt;"/>
			<fileset dir="${deploy.path}">
				<include name="**/*.page"/>
			</fileset>
		</replaceregexp>
		
		<echo><![CDATA[
All Classes and Triggers within the directory: ${deploy.path}
have had their inner code cleared out.

Would you like to deploy now?
(You can check the code in your IDE before continuing)

You can always deploy later by typing
>ant deploy

]]></echo>
		<input addproperty="shouldDeploy" validargs="y,n" defaultvalue="y" />
		<if>
			<equals arg1="${shouldDeploy}" arg2="y" />
			<then>
				<antcall target="deploy" />
			</then>
		</if>
	</target>
	
	
	
	
	<!--
	/**
	 *  Creates a new package file.
	 *  <p>For convenience, the addPackageMember logic is folded in, since no package could ever exist without any data.</p>
	 **/
	--> 
	<target name="newPackage" description="creates a new package file">
		<copy overwrite="true" file="${force.package.template}" tofile="${force.package.path}" />
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	Package targets
	(temporarily placed here)
	@TODO - make these work with packageLists instead of packages.
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!-- 
	/**
	 *  Lists the metadata for the current org.
	**/
	 -->
    <target name="listMetadata" description="Lists metadata types">
		<sf:describeMetadata username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Lists all the items for a particular metadata type
	 **/
	--> 
	<target name="listMetadataTypes" description="Lists all the items for a particular metadata type">
		<antcall target="listMetadataTypesInternal" inheritall="yes" />
	</target>
	
	
	
	<!--
	/**
	 *  Lists all the items for a particular metadata type
	 **/
	--> 
	<target name="listMetadataFiles" description="Lists all the items for a particular metadata type">
		<echo><![CDATA[
Which metadata type?
(Optional: Enter dash '-' for a list of available types)
]]></echo>

		<input
			addproperty="metadata.type"
		/>
		
		<if>
			<or>
				<equals arg1="${metadata.type}" arg2="" />
				<equals arg1="${metadata.type}" arg2="-" />
			</or>
			<then>
				<!-- list out the names of metadata types -->
				<antcall target="listMetadataTypesInternal" />
			</then>
			<else>
				<echo><![CDATA[
Retrieving ${metadata.type}...
(... please wait)
]]></echo>
				<!-- print simplified version to screen -->
				<antcall target="listMetadataFilesInternal" inheritall="yes" />
			</else>
		</if>
	</target>
	
	
	
	
	<!--
	/**
	 *  adds a member from the package xml file
	 **/
	--> 
	<target name="addPackageMember" description="adds a member from the package xml file">
		<property name="source.file" value="${packageToChange}" />
		
		<echo>What metadata type?
(Optional: enter dash '-' for a list of available types)</echo>
		<input
			addproperty="metadata.type"
		/>
		
		<if>
			<or>
				<equals arg1="${metadata.type}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
			<elseif>
				<or>
					<equals arg1="${metadata.type}" arg2="-" />
				</or>
				<then>
					<antcall target="listMetadataTypesInternal" />
					<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
				</then>
			</elseif>
		</if>
		
		<echo><![CDATA[
What member should be added to ${metadata.type}s
(use a comma separated list for multiple entries)
]]></echo>
		<input
			addproperty="metadata.members"
		/>
		<if>
			<or>
				<equals arg1="${metadata.members}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<foreach list="${metadata.members}"
			target="addPackageMemberInternal"
			param="metadata.member"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Retrieves a list of the current members of a type for adding
	 **/
	--> 
	<target name="addPackageType" description="Retrieves a list of the current members of a type for adding">
		<echo>From the following list of metadata types:</echo>
		<antcall target="listMetadataTypesInternal" />
		
		<echo>Which metadata type would you like to add to the package?
(Note: Salesforce api is case sensitive)
</echo>

		<input
			addproperty="metadata.type"
		/>
		
		<if>
			<or>
				<equals arg1="${metadata.type}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<foreach list="${metadata.type}"
			target="addPackageTypeInternal"
			param="metadata.type"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Add in the standard objects
	 **/
	-->
	<target name="addStandardObjects" description='Adds the standard objects to the list of custom objects'>
		<property name="metadata.members" value="Account,AccountContactRole,Activity,Asset,Campaign,CampaignMember,Case,CaseContactRole,Contact,ContentVersion,Contract,ContractContactRole,Event,Idea,Lead,Opportunity,OpportunityContactRole,OpportunityLineItem,PartnerRole,Product2,SfoMatchHistoryItem,Site,Solution,Task,User,UserLicense" />
		<property name="metadata.type" value="CustomObject" />
		
		<foreach list="${metadata.members}"
			target="addPackageMemberInternal"
			param="metadata.member"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Add in all metadata used for documentation
	 **/
	-->
	<target name="addDocMetadata"
		description="Adds in all metadata used for documentation"
	>
		<if>
			<equals arg1="${force.package.exists}" arg2="$${force.package.exists}" />
			<then>
				<antcall target="newPackage" />
			</then>
		</if>
		
		<echo><![CDATA[

## NOTE ##
Metadata members used for documentation are:
${DocMetadataTypes}

To use only a subset (such as working on an edition without Apex,
include the following argument to Ant with the offending items removed:
(from jenkins)
DocMetadataTypes=${DocMetadataTypes}
or
(from ant commandline)
-DDocMetadataTypes=${DocMetadataTypes}
]]></echo>
		
		<property name="addAllOverride" value="y" />
		<property name="ignoreExternalMetadata" value="y" />
		
		<property name="metadata.member" value="*" />
		
		<foreach list="${DocMetadataTypes}"
			target="addPackageMemberInternal"
			param="metadata.type"
			delimiter=","
			inheritall="true"
			trim="true"
			parallel="false"
		/>
		
		<!--
		<antcall target="removeExternalPackageMembers" />
		-->
		
		<echo><![CDATA[
Added in all metadata types used for documentation
]]></echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Add in all metadata used for documentation
	 **/
	-->
	<target name="addDocMetadataByName"
		description="Adds in all metadata used for documentation"
	>
		<if>
			<equals arg1="${force.package.exists}" arg2="$${force.package.exists}" />
			<then>
				<antcall target="newPackage" />
			</then>
		</if>
		
		<echo><![CDATA[

## NOTE ##
Metadata members used for documentation are:
${DocMetadataTypes}

To use only a subset (such as working on an edition without Apex,
include the following argument to Ant with the offending items removed:
(from jenkins)
DocMetadataTypes=${DocMetadataTypes}
or
(from ant commandline)
-DDocMetadataTypes=${DocMetadataTypes}
]]></echo>
		
		<property name="addAllOverride" value="y" />
		<property name="ignoreExternalMetadata" value="y" />
		
		<foreach list="${DocMetadataTypes}"
			target="addPackageTypeInternal"
			param="metadata.type"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<!--
		<antcall target="removeExternalPackageMembers" />
		-->
		
		<echo><![CDATA[
Added in all metadata types used for documentation
]]></echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
    
	
	
	<!--
	/**
	 *  Adds all package types to the current package
	**/
	-->
	<target name="addAllPackageTypes" description="Adds available types to the package" >
		<antcallback target="listMetadataTypesInternal" inheritall="true" return="metadataSimpleResults" />
		<propertyregex property="fullLine" input="${metadataSimpleResults}" regexp="\s+" replace="," global="true" />
		<echo>all lines: ${fullLine}</echo>
		
		<property name="addAllOverride" value="y" />
		
		<foreach list="${fullLine}"
			target="addPackageTypeInternal"
			param="metadata.type"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
    
    
    
    
    <!--
	/**
	 *  removes a member from the package xml file
	 **/
	--> 
	<target name="removePackageMember" description="removes a member from the package xml file">
		<echo>What metadata type?
(Optional: enter dash '-' for a list of available types)</echo>
		<input
			addproperty="metadata.type"
		/>
		
		<if>
			<or>
				<equals arg1="${metadata.type}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<echo><![CDATA[
What member should be removed to ${metadata.type}s
(use a comma separated list for multiple entries)
]]></echo>
		<input
			addproperty="metadata.members"
		/>
		<if>
			<or>
				<equals arg1="${metadata.members}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<foreach list="${metadata.members}"
			target="removePackageMemberInternal"
			param="metadata.member"
			delimiter=","
			inheritall="true"
			trim="true"
		/>
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
    
    
    
    
    <!--
	/**
	 *  Removes all external metadata/members from the package - such as app exchange
	 **/
	--> 
	<target name="removeExternalPackageMembers"
		description="Removes all external metadata/members from the package - such as app exchange"
	>
		<replaceregexp encoding="UTF-8" flags="img"
			 file="${force.package.path}"
			match="__"
			replace="†"
		/>
		<replaceregexp encoding="UTF-8" flags="img"
			file="${force.package.path}"
			match="\s*&lt;members&gt;[^\n&lt;†]*†[^\n&lt;]*&lt;/members&gt;"
			replace=""
		/>
	</target>
	
	
	
	<!--
	/**
	 *  removes a type from the package xml file
	 **/
	--> 
	<target name="removePackageType" description="removes a type from the package xml file">
		<echo><![CDATA[
What metadata type?
(Optional: enter dash '-' for a list of available types)
]]></echo>
		<input
			addproperty="metadata.type"
		/>
		
		<if>
			<or>
				<equals arg1="${metadata.type}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
			<elseif>
				<or>
					<equals arg1="${metadata.type}" arg2="-" />
				</or>
				<then>
					<antcall target="listMetadataTypesInternal" />
					<mm:Success isAbort='true' msg="${abort.user}" />
				</then>
			</elseif>
		</if>
		
		
		<mm:SFDC_RemovePackageType sourceFile="${force.package.path}" targetFile="${force.package.path}"
			metadataType="${metadata.type}"
			isChatty="false"
		/>
		
		<echo>wrote to file:${force.package.path}</echo>
		<antcall target="listPackageToChange" inheritall="true" />
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	GIT targets
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!--
	/**
	 *  Removes all files from the SRC directory except for the package.xml file
	 *  so a clean refresh will not include any files that have been deleted within
	 *  SalesForce.com.
	 *  
	 *  <p>This is especially useful prior to running "ant refresh" to see which files
	 *  have been deleted in SalesForce for reporting.</p>
	**/
	-->
	<target name="resetSrc"
		description="deletes all files from the src directory except for the package.xml file"
	>
		<property name="destructiveChangesPre.tmp" value="${tmp.path}/${destructiveChangesPre.file}" />
		<property name="destructiveChangesPost.tmp" value="${tmp.path}/${destructiveChangesPost.file}" />
		
		<available file="${destructiveChangesPre.path}"  type="file" property="destructiveChangesPre.exists"  />
		<available file="${destructiveChangesPost.path}" type="file" property="destructiveChangesPost.exists" />
		
		<copy overwrite="true" file="${force.package.path}" tofile="${tmp.file.path}" />
		
		<if>
			<and><not><equals arg1="${destructiveChangesPre.exists}" arg2="$${destructiveChangesPre.exists}" /></not></and>
			<then><move overwrite="true" file="${destructiveChangesPre.path}"  tofile="${destructiveChangesPre.tmp}"  /></then>
		</if>
		<if>
			<and><not><equals arg1="${destructiveChangesPost.exists}" arg2="$${destructiveChangesPost.exists}" /></not></and>
			<then><move overwrite="true" file="${destructiveChangesPost.path}" tofile="${destructiveChangesPost.tmp}" /></then>
		</if>
		
		
		<delete includeemptydirs="true">
			<fileset dir="${src.path}">
				<include name="**/*" />
				<exclude name="package.xml" />
			</fileset>
		</delete>
		
		<copy overwrite="true" file="${tmp.file.path}" tofile="${force.package.path}" />
		
		<if>
			<and><not><equals arg1="${destructiveChangesPre.exists}" arg2="$${destructiveChangesPre.exists}" /></not></and>
			<then><move overwrite="true" file="${destructiveChangesPre.tmp}"  tofile="${destructiveChangesPre.path}"  /></then>
		</if>
		<if>
			<and><not><equals arg1="${destructiveChangesPost.exists}" arg2="$${destructiveChangesPost.exists}" /></not></and>
			<then><move overwrite="true" file="${destructiveChangesPost.tmp}" tofile="${destructiveChangesPost.path}" /></then>
		</if>
		
		
	</target>
	
	
	
	<!--
	/**
	 *  provides a merge between what is in version control and what is in the code
	**/
	-->
	<target name="mergeCurrentCode"
		description="Merges current code with the latest from head"
	>
		<!--<echo>${codeHomeRepoOffset}</echo>-->
		<if>
			<or>
				<equals arg1="${codeHomeRepoOffset}" arg2="$${codeHomeRepoOffset}" />
				<equals arg1="${codeHomeRepoOffset}" arg2="" />
			</or>
			<then>
				<echo><![CDATA[
The offset to the src directory from the repostitory home is not defined.
(codeHomeRepoOffset)

Please provide that value in order to continue.]]></echo>
				<mm:Halt><![CDATA[CodeHomeRepoOffset not defined]]></mm:Halt>
			</then>
		</if>
		
		<antcallback target="getDirList" return="dir.list">
			<param name="base.dir" value="${src.path}" />
		</antcallback>
		
		<echo><![CDATA[What type of file is it?]]></echo>
		<input addproperty="dir.name" validargs="${dir.list}" />
		
		<antcallback target="getFileList" return="file.list">
			<param name="base.dir" value="${src.path}/${dir.name}" />
		</antcallback>
		
		<echo><![CDATA[What file should we merge?]]></echo>
		<input addproperty="target.name" validargs="${file.list}" />
		<property name="target.path" value="${src.path}/${dir.name}/${target.name}" />
		
		<!-- copy the existing file -->
		<copy file="${target.path}" tofile="${tmp.file.path}" overwrite="true" />
		
		<!-- get the old version of the file -->
		<exec executable='git' dir='${codeHome}' output="${tmp2.file.path}">
			<arg value='show' />
			<arg value='HEAD:${codeHomeRepoOffset}/${dir.name}/${target.name}' />
		</exec>
		<loadfile srcfile="${tmp2.file.path}" property="tmp2.contents" />
		<condition property="badCodeHome">
			<matches pattern="^fatal:\s*Path" string="${tmp2.contents}" />
		</condition>
		<if>
			<not><equals arg1="${badCodeHome}" arg2="$${badCodeHome}" /></not>
			<then>
				<mm:Halt><![CDATA[
It appears that your codeHomeRepoOffset in build.properties is incorrect.

We were expecting the file to be in your repository (not this project) at
${codeHomeRepoOffset}/${dir.name}/${target.name}

But GIT says it cannot find that file.

The code we ran was:
git show HEAD:${codeHomeRepoOffset}/${dir.name}/${target.name}
in your source code directory:
${codeHome}

Please change your codeHomeRepoOffset in build.properties before trying again.
]]></mm:Halt>
			</then>
		</if>
		
		<echo>Opening DiffMerge</echo>
		<exec executable="diffmerge">
			<arg value="-m" />
			<arg value="${tmp2.file.path}" />
			<arg value="${target.path}" />
			<arg value="${tmp.file.path}" />
		</exec>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Lists the changes in a specific file for a revision range
	**/
	 -->
	<target name="listFileChanges"
		description="lists the changes to a specific file for a revision range"
	>
		<antcallback target="checkCodeHome" return="codeHome" />

		<echo>
What is the name of the file
(assumes src as the base folder)
</echo>
		<input addproperty="target.file" />
		
		<exec executable="git" dir="${codeHome}">
			<arg value="log" />
			<arg value="--pretty=oneline" />
			<arg value="${target.file}" />
		</exec>
		
		<echo>
		
		</echo>
		
		<antcallback target="getRevisionRange" return="revisionStart,revisionEnd" />
		
		<echo><![CDATA[git diff ${revisionStart} ${revisionEnd} ${target.file}]]></echo>
		<exec executable="git" outputproperty="git.changelog" dir="${codeHome}">
			<arg value="diff" />
			<arg value="${revisionStart}" />
			<arg value="${revisionEnd}" />
			<arg value="${target.file}" />
		</exec>
		
		<echo>${git.changelog}</echo>
	</target>
	
	
	
	
	<!--
	/**
	 *  Does a list between different commits
	 **/
	-->
	<target name="listGitCommits"
		description="Lists the commits for a specific range"
	>
		<echo><![CDATA[
What is the starting commit?
(Default is 10th commit from HEAD, but can be a specific SHA)
(Note: this does not include the revision specified)
]]></echo>
		<input addproperty="startCommit" defaultvalue="HEAD~10" />
		
		<echo><![CDATA[
What is the ending commit?
]]></echo>
		<input addproperty="endCommit" defaultValue="HEAD" />
		
		<exec executable="git" dir="${src.path}">
			<arg line="log --no-merges --pretty=oneline ${startCommit}...${endCommit}" />
		</exec>
		
		<echo><![CDATA[
git log --pretty=oneline ${startCommit}...${endCommit}
]]></echo>
	</target>
	
	
	
	<!--
	/**
	 *  Pulls the latest code from version control on the current branch
	 *  (Only needed if running option 1 - using a symbolic link)
	**/
	-->
	<target name="pull"
		description="pulls the latest code from version control for the force directory."
	>
		<exec executable="git" dir="${src.path}">
			<arg value="pull" />
		</exec>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Runs a git command on the salesforce metadata.
	 *  (Only needed if running option 1 - using a symbolic link)
	**/
	-->
	<target name="gitCmd"
		description="Runs a git command on the salesforce metadata (used for option 1)"
	>
		<echo><![CDATA[
What git command should we run?
(i.e. diff, branch, remote show origin, etc)

Examples:
log --pretty=oneline HEAD~10...HEAD
gives the list of the last 10 commits.

status

diff

--

To run the command in one line run
ant gitCmd -DD="[[Your Command]]"
]]></echo>
		<input addproperty="D" />
		<echo><![CDATA[
running
git ${D}
]]></echo>
		<exec executable="git" dir="${src.path}">
			<arg line="${D}" />
		</exec>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Create a package list for changes between revisions
	**/
	 -->
	<target name="createRevisionList"
		description="creates a package list based on a range of revisions"
	>
		
		<antcallback target="checkCodeHome" return="codeHome" />
		
		<antcallback target="getRevisionRange" return="revisionStart,revisionEnd" />
		
		<antcallback target="createRevisionList_internal" return="revisionListContents">
			<param name="revisionStart" value="${revisionStart}" />
			<param name="revisionEnd" value="${revisionEnd}" />
		</antcallback>
		
		<echo>What should we call the file package?</echo>
		<input addproperty="filePackage.file" defaultvalue="revision.txt" />
		<if>
			<or>
				<equals arg1="${filePackage.file}" arg2="$${filePackage.file}" />
				<equals arg1="${filePackage.file}" arg2="" />
			</or>
			<then>
				<var name="filePackage.file" unset="true" />
				<property name="filePackage.file" value="revision.txt" />
			</then>
		</if>
		
		<property name="target.path" value="${packageLists.path}/${filePackage.file}" />
		
		<echo file="${target.path}"><![CDATA[
#from: ${revisionStart} to ${revisionEnd}
${revisionListContents}
]]></echo>
		
		<echo><![CDATA[
#from: ${revisionStart} to ${revisionEnd}
${revisionListContents}

Complete - wrote to: ${target.path}
]]></echo>
	</target>
	
	
	
	<!--
	/**
	 * Determines the changes inline so it can be used in multiple places
	 * @param startCommit
	 * @param endCommit
	 * @return revisionListContents
	 **/
	-->
	<target name="createRevisionList_internal" >
		<echo><![CDATA[git diff --name-status ${revisionStart} ${revisionEnd}]]></echo>
		<exec executable="git" outputproperty="git.changelog" dir="${src.path}">
			<arg value="diff" />
			<arg value="--name-status" />
			<arg value="${revisionStart}" />
			<arg value="${revisionEnd}" />
			<arg value="." />
		</exec>
		
		<echo file="${tmp.file.path}">${git.changelog}</echo>
		
		<!-- remove files that have been deleted -->
		<antcall target="filterFile" inheritall="true">
			<param name="lineFilter" value="^[^D]" />
			<param name="filterTarget" value="${tmp.file.path}" />
		</antcall>
		
		<!-- remove meta files from package lists. they are included automatically -->
		<replaceregexp encoding="UTF-8" file="${tmp.file.path}"
			match="-meta.xml" replace="‡"
			flags="img" 
		/>
		
		<replaceregexp encoding="UTF-8" file="${tmp.file.path}"
			match="^[^\n‡]+‡.*\s*" replace=""
			flags="img" 
		/>
		
		<!-- remove the file status/src from the file -->
		<replaceregexp encoding="UTF-8" file="${tmp.file.path}"
			match="^\w\s+(src/)?" replace=""
			flags="img" 
		/>
		
		<loadfile srcfile="${tmp.file.path}" property="revisionListContents" />
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	Documentation targets
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!--
	/**
	 *  Cleans the doc directory
	 **/
	-->
	<target name="cleanOutput" description="cleans the documentation directory">
		<delete dir="${output.path}" />
		<mkdir dir="${output.path}" />
		
		<copy overwrite="true" todir="${reportResources.target.path}">
			<fileset dir="${reportResources.path}" />
		</copy>
	</target>
	<target name="cleanDocs" depends="cleanOutput" />
	
	

	
	<!--
	/**
	 * Creates Object reports
	 **/
	-->
	<target name="docObjects" description="Run Report on objects" depends="checkProfiles,checkObjects" >
		<!-- pipe to a secondary folder to allow for flattening regardless of source -->
		<delete dir="${object.result.path}" />
		<delete dir="${xslt.result.path}" />
		<xslt basedir="${src.path}" destdir="${xslt.result.path}"
			includes="**/*.object"
			style="${reports.path}/${object.report}"
		/>
		
		<move todir="${object.result.path}" flatten="true">
			<fileset dir="${xslt.result.path}">
				<include name="**/*.*" />
			</fileset>
		</move>
		<delete dir="${xslt.result.path}" />
		
		<echo><![CDATA[
Done.
Finished writing files out to ${output.path} folder
]]></echo>
		
		<!-- create the index -->
		<property name="object.index.path" value="${object.result.path}/${index.file}" />
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${object.result.path}" />
			<param name="file.match" value="*.html" />
			<param name="remove.extension" value="[.]html" />
		</antcallback>
		
		<echo file="${tmp.section.index.path}"></echo>
		<foreach list="${file.list}"
			target="docObjectsIndex"
			param="docObject.file"
			delimiter=","
			trim="true"
			inheritall="true"
		/>
		
		<var name="indexStr" unset="true" />
		<loadfile srcfile="${tmp.section.index.path}" property="indexStr" />
		
		<copy file="${report.objectNav.template.path}" tofile="${object.index.path}" />
		<replaceregexp encoding="UTF-8" flags="img">
			<regexp pattern="\{\{indexStr\}\}" />
			<substitution expression="${indexStr}" />
			
			<fileset dir="${object.result.path}">
				<include name="*.html" />
			</fileset>
		</replaceregexp>
	</target>
	
	
	
	<target name="docObjectsIndex">
		<echo><![CDATA[Indexing: ${docObject.file}]]></echo>
		<echo file="${tmp.section.index.path}" append="true"><![CDATA[
<li><a href="${docObject.file}.html" target="content">${docObject.file}</a></li>]]></echo>
		
		<replaceregexp encoding="UTF-8" file="${object.result.path}/${docObject.file}.html"
			match="\{\{ObjectName\}\}"
			replace="${docObject.file}"
			flags="img"
		/>
	</target>
	
	
	
	
	<!--
	/**
	 * Documents the profiles
	 **/
	-->
	<target name="docProfiles" description="Run Report on Profiles" depends="checkProfiles,checkObjects" >
		<!-- pipe to a secondary folder to allow for flattening regardless of source -->
		<delete dir="${profile.result.path}" />
		<delete dir="${xslt.result.path}" />
		<xslt basedir="${src.path}" destdir="${xslt.result.path}"
			includes="**/*.profile"
			style="${reports.path}/${profile.report}"
		/>
		
		<move todir="${profile.result.path}" flatten="true">
			<fileset dir="${xslt.result.path}">
				<include name="**/*.*" />
			</fileset>
		</move>
		<delete dir="${xslt.result.path}" />
		
		<echo><![CDATA[
Done.
Finished writing files out to ${output.path} folder
]]></echo>
		<!-- create the index -->
		<property name="profile.index.path" value="${profile.result.path}/${index.file}" />
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${profile.result.path}" />
			<param name="file.match" value="*.html" />
			<param name="remove.extension" value="[.]html" />
		</antcallback>
		
		<echo file="${tmp.section.index.path}"></echo>
		<foreach list="${file.list}"
			target="docProfilesIndex"
			param="docProfile.file"
			delimiter=","
			trim="true"
			inheritall="true"
		/>
		
		<var name="indexStr" unset="true" />
		<loadfile srcfile="${tmp.section.index.path}" property="indexStr" />
		
		<copy file="${report.profileNav.template.path}" tofile="${profile.index.path}" />
		<replaceregexp encoding="UTF-8" flags="img">
			<regexp pattern="\{\{indexStr\}\}" />
			<substitution expression="${indexStr}" />
			
			<fileset dir="${profile.result.path}">
				<include name="*.html" />
			</fileset>
		</replaceregexp>
	</target>
	
	
	
	<target name="docProfilesIndex">
		<echo><![CDATA[Indexing: ${docProfile.file}]]></echo>
		<echo file="${tmp.section.index.path}" append="true"><![CDATA[
<li><a href="${docProfile.file}.html" target="content">${docProfile.file}</a></li>]]></echo>
		
		<replaceregexp encoding="UTF-8" file="${profile.result.path}/${docProfile.file}.html"
			match="\{\{ProfileName\}\}"
			replace="${docProfile.file}"
			flags="img"
		/>
	</target>
	
	
	
	<!--
	/**
	 *  Documents (visual work) flows
	 **/
	-->
	<target name="docFlows" description="Run Report on visual work flows" depends="">
		<var name="flows.found" unset="true" />
		<available file="${src.path}/${flows.meta}" type="dir" property="flows.found" />
				
		<if>
			<not><equals arg1="${flows.found}" arg2="$${flows.found}" /></not>
			<then>
				<!-- pipe to a secondary folder to allow for flattening regardless of source -->
				<delete dir="${flow.result.path}" />
				<delete dir="${xslt.result.path}" />
				<xslt basedir="${src.path}" destdir="${xslt.result.path}"
					includes="**/*.flow"
					style="${reports.path}/${flow.report}"
				/>
				
				<move todir="${flow.result.path}" flatten="true">
					<fileset dir="${xslt.result.path}">
						<include name="**/*.*" />
					</fileset>
				</move>
				<delete dir="${xslt.result.path}" />
				
				<echo><![CDATA[
Done.
Finished writing files out to ${output.path} folder
]]></echo>
				<!-- create the index -->
				<property name="flow.index.path" value="${flow.result.path}/${index.file}" />
				<antcallback target="getDirectoryFiles" return="file.list">
					<param name="source.dir" value="${flow.result.path}" />
					<param name="file.match" value="*.html" />
					<param name="remove.extension" value="[.]html" />
				</antcallback>
				
				<echo file="${tmp.section.index.path}"></echo>
				<foreach list="${file.list}"
					target="docFlowsIndex"
					param="docFlow.file"
					delimiter=","
					trim="true"
					inheritall="true"
				/>
				
				<var name="indexStr" unset="true" />
				<loadfile srcfile="${tmp.section.index.path}" property="indexStr" />
				
				<copy file="${report.flowNav.template.path}" tofile="${flow.index.path}" />
				<replaceregexp encoding="UTF-8" flags="img">
					<regexp pattern="\{\{indexStr\}\}" />
					<substitution expression="${indexStr}" />
					
					<fileset dir="${flow.result.path}">
						<include name="*.html" />
					</fileset>
				</replaceregexp>
			</then>
			<else>
				<echo><![CDATA[
No Flows were found. Skipping Flow documentation
]]></echo>
			</else>
		</if>
	</target>
	
	
	
	<target name="docFlowsIndex">
		<echo><![CDATA[Indexing: ${docFlow.file}]]></echo>
		<echo file="${tmp.section.index.path}" append="true"><![CDATA[
<li><a href="${docFlow.file}.html" target="content">${docFlow.file}</a></li>]]></echo>
		
		<replaceregexp encoding="UTF-8" file="${flow.result.path}/${docFlow.file}.html"
			match="\{\{ObjectName\}\}"
			replace="${docFlow.file}"
			flags="img"
		/>
	</target>
	
	
	
	<!--
	/**
	 *  Documents the workflows
	 **/
	-->
	<target name="docWorkflows" description="Run Report on Workflows" depends="checkProfiles,checkWorkflows">
		<!-- pipe to a secondary folder to allow for flattening regardless of source -->
		<delete dir="${workflow.result.path}" />
		<delete dir="${xslt.result.path}" />
		<xslt basedir="${src.path}" destdir="${xslt.result.path}"
			includes="**/*.workflow"
			style="${reports.path}/${workflow.report}"
		/>
		
		<move todir="${workflow.result.path}" flatten="true">
			<fileset dir="${xslt.result.path}">
				<include name="**/*.*" />
			</fileset>
		</move>
		<delete dir="${xslt.result.path}" />
		
		<echo><![CDATA[
Done.
Finished writing files out to ${output.path} folder
]]></echo>
		<!-- create the index -->
		<property name="workflow.index.path" value="${workflow.result.path}/${index.file}" />
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${workflow.result.path}" />
			<param name="file.match" value="*.html" />
			<param name="remove.extension" value="[.]html" />
		</antcallback>
		
		<echo file="${tmp.section.index.path}"></echo>
		<foreach list="${file.list}"
			target="docWorkflowsIndex"
			param="docWorkflow.file"
			delimiter=","
			trim="true"
			inheritall="true"
		/>
		
		<var name="indexStr" unset="true" />
		<loadfile srcfile="${tmp.section.index.path}" property="indexStr" />
		
		<copy file="${report.workflowNav.template.path}" tofile="${workflow.index.path}" />
		<replaceregexp encoding="UTF-8" flags="img">
			<regexp pattern="\{\{indexStr\}\}" />
			<substitution expression="${indexStr}" />
			
			<fileset dir="${workflow.result.path}">
				<include name="*.html" />
			</fileset>
		</replaceregexp>
	</target>
	
	
	
	<target name="docWorkflowsIndex">
		<echo><![CDATA[Indexing: ${docWorkflow.file}]]></echo>
		<echo file="${tmp.section.index.path}" append="true"><![CDATA[
<li><a href="${docWorkflow.file}.html" target="content">${docWorkflow.file}</a></li>]]></echo>
		
		<replaceregexp encoding="UTF-8" file="${workflow.result.path}/${docWorkflow.file}.html"
			match="\{\{ObjectName\}\}"
			replace="${docWorkflow.file}"
			flags="img"
		/>
	</target>
	
	
	
	
	<!--
	/**
	 *  Creates workbook documents
	 **/
	-->
	<target name="docWorkbooks" description="Create object workbooks" depends="checkProfiles,checkObjects">
		<!-- pipe to a secondary folder to allow for flattening regardless of source -->
		<delete dir="${workbook.result.path}" />
		<delete dir="${xslt.result.path}" />
		<xslt basedir="${src.path}" destdir="${xslt.result.path}"
			includes="**/*.object"
			extension=".xls"
			style="${reports.path}/${workbook.report}"
		/>
		
		<move todir="${workbook.result.path}" flatten="true">
			<fileset dir="${xslt.result.path}">
				<include name="**/*.*" />
			</fileset>
		</move>
		<delete dir="${xslt.result.path}" />
		
		<echo><![CDATA[
Done.
Finished writing files out to ${output.path} folder
]]></echo>
		
		<!-- create the index -->
		<property name="workbook.index.path" value="${workbook.result.path}/${index.file}" />
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${workbook.result.path}" />
			<param name="file.match" value="*.xls" />
			<param name="remove.extension" value="[.]xls" />
		</antcallback>
		
		<echo file="${tmp.section.index.path}"></echo>
		<foreach list="${file.list}"
			target="docWorkbooksIndex"
			param="docWorkbook.file"
			delimiter=","
			trim="true"
			inheritall="true"
		/>
		
		<var name="indexStr" unset="true" />
		<loadfile srcfile="${tmp.section.index.path}" property="indexStr" />
		
		<copy file="${report.workbookNav.template.path}" tofile="${workbook.index.path}" />
		<replaceregexp encoding="UTF-8" file="${workbook.index.path}"
			match="\{\{indexStr\}\}"
			replace="${indexStr}"
			flags="img"
		/>
	</target>
	
	
	
	<target name="docWorkbooksIndex">
		<echo><![CDATA[Indexing: ${docWorkbook.file}]]></echo>
		<echo file="${tmp.section.index.path}" append="true"><![CDATA[
<li><a href="${docWorkbook.file}.xls" target="content" download="${docWorkbook.file}.xls">${docWorkbook.file}.xls</a></li>]]></echo>
		
		<replaceregexp encoding="UTF-8" file="${workbook.result.path}/${docWorkbook.file}.xls"
			match="\{\{ObjectName\}\}"
			replace="${docWorkbook.file}"
			flags="img"
		/>
	</target>
	
	
	
	
	<!--
	/**
	 *  Creates a matrix report based on the profiles currently retrieved
	 **/
	-->
	<target name="matrix" description="Creates a Profile Matrix" depends="checkProfiles,checkObjects">
		<echo><![CDATA[

What type of matrix report would you like?
]]></echo>
		<input
			addProperty="matrixType"
			validargs="all,object,class,field,layout,recordType,page"
			defaultvalue="object"
		/>
		
		<echo file="${tmp.section.index.path}"></echo>
		
		<if>
			<equals arg1="${matrixType}" arg2="all" />
			<then>
				<var name="matrixType" unset="true" />
				
				<foreach list="object,class,field,layout,recordType,page"
					param="matrixType"
					target="matrix_type"
					delimiter=","
					inheritall="true"
					trim="true"
				/>
			</then>
			<else>
				<antcall target="matrix_type" inheritall="true" />
			</else>
		</if>
		
		<!-- create the index -->
		<property name="matrix.index.path" value="${matrix.result.path}/${index.file}" />
		
		<var name="indexStr" unset="true" />
		<loadfile srcfile="${tmp.section.index.path}" property="indexStr" />
		
		<copy file="${report.matrixNav.template.path}" tofile="${matrix.index.path}" />
		<replaceregexp encoding="UTF-8" file="${matrix.index.path}"
			match="\{\{indexStr\}\}"
			replace="${indexStr}"
			flags="img"
		/>
	</target>
	
	
	
	<!--
	Internal targt to run a particular type of matrix report
	-->
	<target name="matrix_type" >
		<var name="profile.path" unset="true" />
		<var name="targetFile" unset="true" />
		
		<!-- <delete dir="${output.path}/matrix" /> -->
		<mkdir dir="${output.path}/matrix" />
		
		<property name="profile.path" value="${src.path}/${profiles.meta}" />
		<property name="permissionSet.path" value="${src.path}/${permissionSet.meta}" />
		<property name="targetFile" value="${matrixType}_matrix.csv" />
		<property name="targetFile.path" value="${matrix.result.path}/${targetFile}" />
		
		<mm:SFDC_CrudMatrix
			profileDirectory="${profile.path}"
			permissionDirectory="${permissionSet.path}"
			resultFilePath="${targetFile.path}"
			type="${matrixType}"
		/>
		
		<echo file="${tmp.section.index.path}" append="true"><![CDATA[
<li><a href='${targetFile}'>${matrixType} Matrix.csv</a></li>]]></echo>
		
		<echo><![CDATA[

Saved to ${targetFile.path}]]>
</echo>
	</target>
	
	
	
	
	<!--
	/**
	 *  provides a merge between what is in version control and what is in the code
	**/
	-->
	<target name="docCode"
		description="Runs ApexDoc on the current set of apex classes"
	>
		<java
			jar="${antlib}/SfApexDoc.jar" fork="true"
		>
			<arg value="-s" />
			<arg value="${classes.path}" />
			<arg value="-t" />
			<arg value="${output.path}" />
			<!-- 
			<arg value="-x" />
			<arg value="cls" />
			-->
		</java>
		
		<!--
		<fail><![CDATA[
		copying from [ApexDoc.css.path] [${ApexDoc.css.path}]
		to [ApexDoc.css.target] [${ApexDoc.css.target}]
		]]></fail>
		-->
		<!--
		<copy overwrite="true" file="${ApexDoc.css.path}" tofile="${ApexDoc.css.target}" />
		-->
		<move file="${code.index.path}" tofile="${code.index.target}" />
		<copy file="${report.codeNav.template.path}" tofile="${code.index.path}" />
		
		
		<echo><![CDATA[

Documentation completed.

Docs generated in folder ${output.path}
or
${code.index.path}

See
http://techsahre.blogspot.com/2011/01/apexdoc-salesforce-code-documentation.html
for more information on code formatting.

...

Would you like to try opening the docs now?
(Please note, only Mac OSX supported)
]]></echo>

		<input
			addproperty="shouldOpenCode"
			defaultvalue="y"
			validargs="y,n"
		/>
		<if>
			<equals arg1="${shouldOpenCode}" arg2="y" />
			<then>
				<antcall target="openInBrowser">
					<param name="open.baseDir" value="${code.result.path}" />
					<param name="open.file" value="index.html" />
				</antcall>
			</then>
		</if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Creates an html report of current changes as an HTML report.
	**/
	-->
	<target name="docDiffChanges"
		description="Creates a report of the current changes in the local copy"
	>
		<!-- determine head -->
		<exec executable="git" dir="${src.path}" outputproperty="src.head">
			<arg line="log --pretty=format:'%H' -n 1" />
		</exec>
		
		<exec executable="git" dir="${src.path}" outputproperty="src.status">
			<arg line="status" />
		</exec>
		
		<echo file="${diffReport.header.path}"><![CDATA[
The following are a list of changes not in version control.

At least according to:
${src.head}

Quick reminder:
Changes not staged for commit / modified are things that have changed.
Untracked changes are items that git previously didn't know about.

${src.status}
]]></echo>
		
		<exec executable="git" dir="${src.path}" output="${diffReport.diff.path}">
			<arg line="diff -U30 ." />
		</exec>
		
		<exec executable="python" dir="." input="${diffReport.diff.path}" output="${diffReport.index.target}">
			<arg line="diff2html.py" />
		</exec>
		
		<replaceregexp encoding='UTF-8' file='${diffReport.index.target}'
			match="&lt;!--###GIT_STATUS###--&gt;"
			replace="${src.status}"
			flags='img'
		/>
		
		<echo><![CDATA[
Report generated at ${diffReport.index.target}
]]></echo>
	</target>
	
	
	
	
	<!--
	/**
	 *  Creates a report on the changes that occurred between two specific commits
	**/
	-->
	<target name="docChanges"
		description="Provides a report of changes that occurred since last asked"
	>
		<!-- end revision to use -->
		<exec executable="git" dir="${src.path}" outputproperty="end.docChanges">
			<arg line="log --pretty=format:'%H' -n 1" />
		</exec>
		
		<!-- determine if the property file includes the last commit to check against -->
		<condition property='hasLastCommit'>
			<resourcecontains resource='build.properties' substring="docChanges.lastCommit=" />
		</condition>
		
		<!-- if the docChanges isn't defined, then set it to head, and let it run so it can run next time -->
		<if>
			<or>
				<equals arg1="${docChanges.lastCommit}" arg2="$${docChanges.lastCommit}" />
				<equals arg1="${docChanges.lastCommit}" arg2="" />
			</or>
			<then>
				<if>
					<equals arg1="${hasLastCommit}" arg2="$${hasLastCommit}" />
					<then>
						<echo><![CDATA[
No commit was defined as the last commit to reference for changes.

Using HEAD as default

Please run
>ant lastChangeCommit

to change.
]]></echo>
					</then>
				</if>
				
				<antcall target="lastChangeCommit">
					<param name="lastChangeCommit" value="${end.docChanges}" />
				</antcall>
				
				<var name="docChanges.lastCommit" unset="true" />
				<property file="build.properties" />
				
			</then>
		</if>
		
		<copy overwrite="true" file="${report.change.template.path}" tofile="${change.index.target}" />
		
		<echo file="${change.result.file.path}"><![CDATA[
#	#	#	#	#	#	#	#	#	#	#	#	
Files changed
FROM: ${docChanges.lastCommit}
TO  : ${end.docChanges}
#	#	#	#	#	#	#	#	#	#	#	#	

]]></echo>
		
		<!-- determine the list of files changed -->
		<antcallback target="createRevisionList_internal" return="revisionListContents">
			<param name="revisionStart" value="${docChanges.lastCommit}" />
			<param name="revisionEnd" value="${end.docChanges}" />
		</antcallback>
		
		<echo file="${change.result.file.path}" append="true"><![CDATA[

${revisionListContents}

#	#	#	#	#	#	#	#	#	#	#	#	
All Documentated Metadata Changes
FROM: ${docChanges.lastCommit}
TO  : ${end.docChanges}
#	#	#	#	#	#	#	#	#	#	#	#	


]]></echo>
		
		<echo><![CDATA[
generating list of log commits.
log --no-merges --stat ${docChanges.lastCommit}..${end.docChanges} -- .
]]></echo>
		
		<exec executable="git" dir="${src.path}" output="${change.result.file.path}" append="true">
			<arg line="log --no-merges --stat ${docChanges.lastCommit}..${end.docChanges} -- ." />
		</exec>
		
		<!--
		/**
		 *  for now, don't update the last change commit
		 *  instead, require the calling of lastChangeCommit so it can be a bit more manual.
		**/
		<antcall target="lastChangeCommit">
			<param name="lastChangeCommit" value="${end.docChanges}" />
		</antcall>
		-->
		
		<echo><![CDATA[

Changes logged to ${change.result.file.path}

(To change the starting commit, please run
>ant lastChangeCommit
]]></echo>
	</target>
	
	
	
	
	<!--
	/** 
     *  Documents everything
     **/
    -->
    <target name="docAllAuto" description="Runs all documentation reports">
    	<antcall target="docAll">
    		<param name="shouldOpenDocs" value="n" />
    	</antcall>
    </target>
	
	
	
	
	<!--
	/** 
     *  Documents everything
     **/
    -->
    <target name="docAll" description="Runs all documentation reports">
		
    	<delete dir="${output.path}" />
		<mkdir dir="${output.path}" />
		
		<antcall target="docAll_internal" inheritall="true" >
			<param name="matrixType" value="all" />
			<param name="shouldOpenCode" value="n" />
		</antcall>
		
		<property name="updateIndex" value="y" />
		
		<property name="autodoc.target" value="autoDoc" />
		<!-- <property name="autodoc.target" value="doc_${timestamp.numeric}" /> -->
		
		<antcall target="updateIndices" inheritall="true" />
		
		<antcallback target="archiveDocs" return='doc.zip.path'>
			<param name="doc.zip.name" value="${autodoc.target}" />
		</antcallback>
		
		<echo><![CDATA[
${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}
${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}${n}
Complete.

All code generated in the ${output.path} folder

archived at: ${doc.zip.path}
]]></echo>
		
		<echo><![CDATA[
Would you like to open the docs now?
]]></echo>
		
		<input
			addproperty="shouldOpenDocs"
			defaultvalue="y"
			validargs="y,n"
		/>
		<if>
			<equals arg1="${shouldOpenDocs}" arg2="y" />
			<then>
				<antcall target="openInBrowser">
					<param name="open.baseDir" value="${output.path}" />
					<param name="open.file" value="index.html" />
				</antcall>
			</then>
		</if>
    </target>
    
    <target name="docAll_internal">
    	
    	<!--
    	#FIX: instead of making the docAll depend on all tags,
    	making them instead iterate over a list allows the user to specify
    	a different set of 'all targets'
    	so some could be removed if not necessary
    	
    	such as the following for PE
		<property name="PE_docAll_targets" value="cleanDocs,matrix,docFlows,docObjects,docProfiles,docWorkbooks,docChanges" />
    	-->
    	
    	<property name="docAll_targets" value="cleanDocs,matrix,docFlows,docObjects,docProfiles,docWorkflows,docWorkbooks,docCode,docChanges" />
    	
    	<for list="${docAll_targets}" param="docAllTarget" delimiter=',' keepgoing='true' >
    		<sequential>
    			<echo>target[@{docAllTarget}]</echo>
    			<antcall target="@{docAllTarget}" inheritall="true" />
    		</sequential>
    	</for>
    </target>
    
    
    
    <!--
    Zips the output folder
    -->
    <target name="archiveDocs"
    	description="Archives the documentation generated"
    >
		<property name="doc.zip.name.default" value="doc_${timestamp.numeric}" />
		<echo><![CDATA[
What do you want the archived documentation zip to be called?
(default: ${doc.zip.name.default})
]]></echo>
		<input addproperty="doc.zip.name" />
		<if>
			<equals arg1="${doc.zip.name}" arg2="" />
			<then>
				<var name="doc.zip.name" unset="true" />
				<property name="doc.zip.name" value="${doc.zip.name.default}" />
			</then>
		</if>
		<property name="doc.zip.path" value="${doc.zip.name}.zip" />
		<zip destfile="${doc.zip.path}">
			<fileset dir="${output.path}" includes="**/*.*" />
		</zip>
    </target>
	
	
	
	<!--
	/**
	 *  Checks if the objects have been retrieved
	 *  @VISIBILITY: INTERNAL
	 **/
	-->
	<target name="checkRetrieved" description="">
		<var name="retrieve.found" unset="true" />
		<available file="${src.path}/${package.file}" type="file" property="retrieve.found" />
		<if>
			<equals arg1="${retrieve.found}" arg2="$${retrieve.found}" />
			<then>
				<mm:Halt><![CDATA[No files were found at ${src.path} to run reports on.]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	
	
	<!--
	/**
	 *  Checks if the profiles have been retrieved
	 *  @VISIBILITY: INTERNAL
	 **/
	-->
	<target name="checkProfiles" depends="checkRetrieved" >
		<var name="profiles.found" unset="true" />
		<available file="${src.path}/${profiles.meta}" type="dir" property="profiles.found" />
		
		<if>
			<equals arg1="${profiles.found}" arg2="$${profiles.found}" />
			<then>
				<mm:Halt><![CDATA[Profiles were not retrieved.${n}
${n}
Please modify the package at: ${src.path}/package.xml${n}
or${n}
run the following command
ant addPackageType${n}
as that will allow you to specify the packages to be included${n}
${n}
Then call${n}
>ant refresh${n}
to download the latest${n}
]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	<!--
	/**
	 *  Checks if the objects have been retrieved
	 *  @VISIBILITY: INTERNAL
	 **/
	-->
	<target name="checkObjects" depends="checkRetrieved" >
		<var name="objects.found" unset="true" />
		<available file="${src.path}/${objects.meta}" type="dir" property="objects.found" />
		
		<if>
			<equals arg1="${objects.found}" arg2="$${objects.found}" />
			<then>
				<mm:Halt><![CDATA[Objects were not retrieved.${n}
${n}
Please modify the package at: ${src.path}/package.xml${n}
or${n}
run the following command
ant addPackageType${n}
as that will allow you to specify the packages to be included${n}
${n}
Then call${n}
>ant refresh${n}
to download the latest${n}
]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	<!--
	/**
	 *  Checks if the objects have been retrieved
	 *  @VISIBILITY: INTERNAL
	 **/
	-->
	<target name="checkWorkflows" depends="checkRetrieved" >
		<var name="workflows.found" unset="true" />
		<available file="${src.path}/${workflows.meta}" type="dir" property="workflows.found" />
		
		<if>
			<equals arg1="${workflows.found}" arg2="$${workflows.found}" />
			<then>
				<mm:Halt><![CDATA[Workflows were not retrieved.${n}
${n}
Please modify the package at: ${src.path}/package.xml${n}
or${n}
run the following command
ant addPackageType${n}
as that will allow you to specify the packages to be included${n}
${n}
Then call${n}
>ant refresh${n}
to download the latest${n}
]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#		
	Internal Package targets
	@TODO - make these work with packageLists instead of packages.
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!--
	/**
	 *  Prints a list of metadata response types
	 *  @visibility Internal
	 *  @return metadataSimpleResults
	 **/
	-->
	<target name="listMetadataTypesInternal">
		<!-- write out the file but sort and apply a filter -->
		<echo><![CDATA[
Retrieving list of metadata types...
(... please wait)
]]></echo>
		<sf:describeMetadata username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}" resultFilePath="${tmp.file.path}" />
		<echo><![CDATA[
Retrieved.
]]></echo>
		
		<!-- limit to only XML records -->
		<antcall target="filterFile" inheritall="true">
			<param name="lineFilter" value="XMLName:" />
			<param name="filterTarget" value="${tmp.file.path}" />
		</antcall>
		
		<!-- sort the list -->
		<antcall target="sortFile" >
			<param name="sortTarget" value="${tmp.file.path}" />
		</antcall>
		
		<var name="tmpContents" unset="true" />
		<loadfile srcfile="${tmp.file.path}" property="tmpContents" />
		
		<propertyregex
			property="cleanedList"
			input="${tmpContents}"
			regexp="XMLName:\s*"
			replace=""
			global="true"
		/>
		
		<echo><![CDATA[
Matching Metadata Package types:
${cleanedList}
]]></echo>
		
		<property name="metadataSimpleResults" value="${cleanedList}" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Prints a list of files for a specific metadata type
	 *  @visibility Internal
	 *  @return metadataSimpleResults
	 **/
	-->
	<target name="listMetadataFilesInternal" >
		<property name="result.path" value="${tmp.file.path}" />
		
		<echo>
<![CDATA[
Retrieving list of files for metadata type [${metadata.type}]
(... please wait)
]]></echo>
		<trycatch>
			<try>
				<sf:listMetadata username="${retrieve.username}" password="${retrieve.password}" serverurl="${retrieve.serverurl}" metadataType="${metadata.type}" resultFilePath="${result.path}" />
			</try>
			<catch>
				<mm:Halt><![CDATA[${n}
SFDC could not find a metadata type called: ${metadata.type}${n}
${n}
However, SFDC is case sensitive.${n}
${n}
Please check against the list above and try again]]></mm:Halt>
			</catch>
		</trycatch>
		<echo>Retrieved.</echo>
		
		<!-- limit to only XML records -->
		<antcall target="filterFile" inheritall="true">
			<param name="lineFilter" value="FileName:" />
			<param name="filterTarget" value="${result.path}" />
		</antcall>
		
		<!-- sort the list -->
		<antcall target="sortFile" >
			<param name="sortTarget" value="${result.path}" />
		</antcall>
		
		<echo><![CDATA[

All ${metadata.type} files found
]]></echo>
		
		<replaceregexp encoding="UTF-8" file="${result.path}"
			match="^[ \t\n]*"
			replace=""
			flags="img" 
		/>

		<loadfile srcfile="${result.path}" property="initialFileList" />
		<!-- <echo>[${initialFileList}]</echo> -->
		
		<if>
			<equals arg1="${initialFileList}" arg2="$${initialFileList}" />
			<then>
				<property name="shouldAdd" value="n" />
				<property name="metadataSimpleResults" value="" />
			</then>
			<else>
	
				<!-- ask the user if there is a specific file they are looking for -->
				<if>
					<not><equals arg1="${addAllOverride}" arg2="y" /></not>
					<then>
						<antcall target="filterFileInquiry" inheritall="true" >
							<param name="filterTarget" value="${result.path}" />
						</antcall>
					</then>
				</if>
				
				<replaceregexp encoding="UTF-8" file="${result.path}"
					match="[ \t]*FileName:[ \t]*\w+/"
					replace=""
					flags="img" 
				/>
				
				<replaceregexp encoding="UTF-8" file="${result.path}"
					match="\.[a-zA-Z0-9_]+[ \t]*$"
					replace=""
					flags="img"
				/>
				
				<if>
					<equals arg1="${ignoreExternalMetadata}" arg2="y" />
					<then>
						<replaceregexp encoding="UTF-8" flags="img"
							file="${result.path}"
							match="__"
							replace="†"
						/>
						<replaceregexp encoding="UTF-8" flags="img"
							file="${result.path}"
							match="†(.)\b"
							replace="__\1"
						/>
						<replaceregexp encoding="UTF-8" flags="img"
							file="${result.path}"
							match="^\s*[^\n†]*†.*\n"
							replace=""
						/>
					</then>
				</if>
				
				<replaceregexp encoding="UTF-8" file="${result.path}"
					match="\n\s*$"
					replace=""
					flags="img"
				/>
				
				<var name="tmpContents" unset="true" />
				<loadfile srcfile="${result.path}" property="tmpContents" />
				
				<if>
					<not>
						<equals arg1="${tmpContents}" arg2="$${tmpContents}" />
					</not>
					<then>
						<echo><![CDATA[
Files found for [${metadata.type}]:
[${tmpContents}]
]]></echo>
					</then>
				</if>
				
				<property name="metadataSimpleResults" value="${tmpContents}" />
			</else>
		</if>
	</target>
	
	
	
	
	<!--
    /**
     *  Writes out the current packageToChange
     *  <p>This is the package used by the package modification targets</p>
     *  @see removePackageType
     *  @see addPackageMembers
     *  @see removePackageMember
     **/
    -->
    <target name="listPackageToChange" description="Shows the contents of the current package to modify">
    	<loadfile srcfile="${force.package.path}" property="tmpContents" />
    	<echo><![CDATA[
${tmpContents}
]]>
</echo>
    </target>
	
	
	
	
	<!--
	/**
	 *  Internal target that adds a particular member to the current package
	 **/
	-->
    <target name="addPackageMemberInternal">
    	<if>
    		<equals arg1="${addPackageMember.toList}" arg2="y" />
    		<then>
    			<var name="filePackage.dir" unset="true" />
    			<var name="filePackage.file" unset="true" />
    			<var name="filePackage.extension" unset="true" />
    			
    			<mm:SFDC_ConvertMetadataToFolder metadata="${metadata.type}" targetProperty="filePackage.dir" />
    			<mm:SFDC_ConvertMetadataToExtension metadata="${metadata.type}" targetProperty="filePackage.extension" />
    			<property name="filePackage.file" value="${metadata.member}${filePackage.extension}" />
    			
    			<echo>adding ${filePackage.dir}/${filePackage.file} to ${packageList.path}</echo>
    			<echo file="${packageList.path}" append="true"><![CDATA[
${filePackage.dir}/${filePackage.file}
]]></echo>
    		</then>
    		<else>
    			<echo>adding ${metadata.member} to ${metadata.type} ${force.package.path}</echo>
				<mm:SFDC_AddPackageMember sourceFile="${force.package.path}" targetFile="${force.package.path}"
					metadataType="${metadata.type}" member="${metadata.member}"
					isChatty="false"
				/>
    		</else>
    	</if>
    </target>
	
	
	
	<!--
	/**
	 *  Adds a list of metadata types to the current package
	 **/
	-->
	<target name="addPackageTypeInternal" >
		<antcallback target="listMetadataFilesInternal" inheritall="true" return="metadataSimpleResults,result.path" />
		
		<!-- <echo>[${metadataSimpleResults}]</echo> -->
		<if>
			<or>
				<equals arg1="${metadataSimpleResults}" arg2="$${tmpContents}" />
				<equals arg1="${metadataSimpleResults}" arg2="" />
			</or>
			<then>
				<echo><![CDATA[

-- No ${metadata.type} files to add
(press any key to continue)
]]></echo>

				<property name="shouldAdd" value="n" />
				
				<!--
				for now: do not confirm with user that there aren't any files to add.
				
				<var name="nofiles.confirm" unset="true" />
				<input addproperty="nofiles.confirm" />
				-->
			</then>
		</if>
		
		<echo><![CDATA[

Are you sure you wish to add all these items
to the target package file? ${force.package.path}
]]></echo>
		
		<if>
			<and>
				<not><equals arg1="${shouldAdd}" arg2="n" /></not>
				<equals arg1="${addAllOverride}" arg2="y" />
			</and>
			<then>
				<property name="shouldAdd" value="y" />
			</then>
		</if>
		
		<input
			addproperty="shouldAdd"
			validargs="y,n"
			defaultvalue="y"
		/>
		
		<if>
			<equals arg1="${shouldAdd}" arg2="y" />
			<then>
				<!-- propertyregex doesn't work on newlines -->
				<replaceregexp encoding="UTF-8" file="${result.path}"
					match="\n"
					replace=", "
					flags="img"
				/>
				<replaceregexp encoding="UTF-8" file="${result.path}"
					match=",\s*$"
					replace=""
					flags="img"
				/>
				<loadfile srcfile="${result.path}" property="metadataList" />
				
				<if>
					<equals arg1="${metadataList}" arg2="$${metadataList}" />
					<then>
						<echo>-- No files to add</echo>
					</then>
					<else>
						<foreach list="${metadataList}"
							target="addPackageMemberInternal"
							param="metadata.member"
							delimiter=","
							inheritall="true"
							trim="true"
						/>
					</else>
				</if>
			</then>
			<else>
				<echo>-- Skipping files from being added</echo>
			</else>
		</if>
	</target>
	
	
	
	
	<!--
	/**
	 *  Internal target that adds a particular member to the current package
	 **/
	-->
	<target name="removePackageMemberInternal">
    	<echo>removing ${metadata.member} from ${metadata.type}</echo>
		<mm:SFDC_RemovePackageMember sourceFile="${force.package.path}" targetFile="${force.package.path}"
			metadataType="${metadata.type}" member="${metadata.member}"
			isChatty="false"
		/>
    </target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	MEDIUM LEVEL TARGETS
	(these are targets mostly called by people but are likely for advanced users only)
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	
	<!-- 
	/**
	 *  removes metadata files from a package list.
	**/
	 -->
	<target name="cleanupMeta">
		<antcallback target="requestFileList" return="fileList.path" />
		
		<!--
		<property name="fileList.path" value="packageLists/initialImport.txt" />
		-->
		
		<replaceregexp encoding="UTF-8" file="${fileList.path}"
			match="-meta.xml"
			replace="†"
			flags="img" 
		/>
		<replaceregexp encoding="UTF-8" file="${fileList.path}"
			match="^[^\n†]+†.*"
			replace=""
			flags="img" 
		/>
		<replaceregexp encoding="UTF-8" file="${fileList.path}"
			match="${line.separator}(\s*${line.separator})+"
			replace="${line.separator}"
			flags="img" 
		/>
	</target>
	
	
	
	
	<!--
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
	LOW LEVEL TARGETS
	(these are targets only called by other targets)
	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#
	-->
	
	
	
	<!--
	/**
	 *  Opens a web page in the browser
	 *  @param open.baseDir - base directory that contains the file
	 *  @param open.file - file to open
	**/
	-->
	<target name="openInBrowser">
		<!-- add better OS handling -->
		<!-- mac -->
		<trycatch>
			<try>
				<exec executable="open" dir="${open.baseDir}">
					<arg value="${open.file}" />
				</exec>
			</try>
			<catch>
				<echo><![CDATA[
]]></echo>
			</catch>
		</trycatch>
		
		<!-- windows -->
		<!-- need to test -->
		<trycatch>
			<try>
				<exec dir="${open.baseDir}" executable="rundll32.exe">
					<arg line="url.dll, FileProtocolHandler"/>
					<arg line="${open.file}"/>
				</exec>
			</try>
			<catch>
				<echo><![CDATA[
]]></echo>
			</catch>
		</trycatch>
	</target>
	
	
	
	<!--
	/**
	 *  Requests which package list
	 *  @visibility internal
	 *  @return packageList.path
	**/
	-->
	<target name="whichPackageList">
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${packageLists.path}" />
			<param name="file.match" value="*.txt" />
			<param name="remove.extension" value="[.]txt" />
		</antcallback>
		
		<echo><![CDATA[
Which file list should we add it to?
(Current ignore file specified: ${ignore.file})
${file.list}
]]></echo>
		<input addproperty="packageList.name" />
		<property name="packageList.path" value="${packageLists.path}/${packageList.name}.txt" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Lists the contents of a package list
	 *  @param packageList.path
	 *  @visibility internal
	**/
	-->
	<target name="showPackageList_internal">
		<trycatch>
			<try>
				<loadfile srcfile="${packageList.path}" property="packageList.contents" />
				<echo><![CDATA[
${packageList.contents}
]]></echo>
			</try>
			<catch>
				<!-- if the file wasn't added, then the file won't exist and can't be loaded -->
			</catch>
		</trycatch>
	</target>
	
	
	
	
	<!--
	<target name="testContinue"
		description="Tests the continue target"
	>
		<echo>Something happened.</echo>
		<antcall target="pauseContinue" />
		<echo>Done</echo>
	</target>
	-->

	<target name="pauseContinue">
		
		<var name="shouldContinue" unset="true" />
		<property name="continueMsg" value="Would you like to continue?" />
		<if>
			<and>
			<not><equals arg1="${overrideContinue}" arg2="y" /></not>
			<not><equals arg1="${overrideContinue}" arg2="true" /></not>
			</and>
			<then>
			
				<echo>
${continueMsg}</echo>
				
				<input addproperty="shouldContinue"
					defaultvalue="y"
					validargs="y,n"
				/>
				<if>
					<equals arg1="${shouldContinue}" arg2="y" />
					<then>
						<echo>continuing</echo>
					</then>
					<else>
						<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
					</else>
				</if>
			</then>
		</if>
		<var name="continueMsg" unset="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Determines the name of the resource from a file path.
	 *  This is the name of the static resource without the .resource
	**/
	-->
	<target name="getResourcePathBase">
		<var name="resource.name" unset="true" />
		<var name="resource.base" unset="true" />
		
		<propertyregex property="resource.name"
			input="${filePath}"
			regexp="[\//]([^\//]+)$"
			select="\1"
		/>
		<propertyregex property="resource.base"
			input="${resource.name}"
			regexp="(\w+)[.]"
			select="\1"
		/>
		<!--
		<echo>${filePath}</echo>
		<echo>${resource.name}</echo>
		<echo>${resource.base}</echo>
		-->
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Determines the static resource and file names of a static resource base
	 *  @param resource.base
	 *  @return resource.name
	 *  @return resource.file
	**/
	-->
	<target name="getFileResource">
		<var name="resource.name" unset="true" />
		<var name="resource.file" unset="true" />
		<propertycopy name="resource.name" from="${resource.base}.resource" />
		<propertycopy name="resource.file" from="${resource.base}.file" />
		<!--
		<echo>${resource.name} ${resource.file}</echo>
		-->
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Determines the static resource and zip folder names of a static resource base
	 *  @param resource.base
	 *  @return resource.name
	 *  @return resource.zip
	**/
	-->
	<target name="getZipResource">
		<var name="resource.name" unset="true" />
		<var name="resource.zip" unset="true" />
		<propertycopy name="resource.name" from="${resource.base}.resource" />
		<propertycopy name="resource.zip" from="${resource.base}.zip" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Determines the name of the directory for a resource base.
	**/
	-->
	<target name="getResourceBaseDir">
		<property name="extracted.dir" value="${resource.base}_resource" />
		<property name="extracted.path" value="${resources.path}/${extracted.dir}" />
		<!--
		<echo>extracted.dir</echo>
		<echo>extracted.path</echo>
		-->
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Target that either calls the zip resource or the file resource.
	 *  @param resource.base
	**/
	 -->
	<target name="compressResources_internal">
		<antcallback target="findResourceTranslation" return="resource.name,resource.file,resource.zip">
			<param name="resource.base" value="${resource.base}" />
		</antcallback>
		
		<if>
			<not><equals arg1="${resource.file}" arg2="$${resource.file}" /></not>
			<then>
				<!-- compress file since the file translation was defined -->
				<antcall target="compressFileResource">
					<param name="resource.base" value="${resource.base}" />
				</antcall>
			</then>
			<else>
				<antcall target="compressZipResource">
					<param name="resource.base" value="${resource.base}" />
				</antcall>
			</else>
		</if>
		
		<property name="fileExtension" value="resource" />
		<property name="filePackage.dir" value="staticresources" />
		<property name="target.meta.path" value="${src.path}/${filePackage.dir}/${resource.name}${meta_suffix}" />
		<property name="source.meta.path" value="${meta.path}/${filePackage.dir}.meta.template" />
		
		<echo>
fileExtension
filePackage.dir=${filePackage.dir}
target.meta.path=${target.meta.path}
source.meta.path=${source.meta.path}
		</echo>
		
		<available file="${target.meta.path}" type="file" property="target.meta.exists" />
		<if>
			<equals arg1="${target.meta.exists}" arg2="$${target.meta.exists}" />
			<then>
				<echo>meta does not exist</echo>
				<copy file="${source.meta.path}" tofile="${target.meta.path}" />
				<replaceregexp encoding="UTF-8" file="${target.meta.path}"
					match="##VERSION##"
					replace="${SFDC_VERSION}"
					flags="img"
				/>
				<replaceregexp encoding="UTF-8" file="${target.meta.path}"
					match="##FILENAME##"
					replace="${fileName}"
					flags="img"
				/>
			</then>
			<else>
				<echo>meta DOES exist</echo>
			</else>
		</if>
		
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Target that either calls the zip resource or the file resource.
	 *  @param resource.base
	**/
	 -->
	<target name="extractResources_internal">
		<antcallback target="findResourceTranslation" return="resource.name,resource.file,resource.zip">
			<param name="resource.base" value="${resource.base}" />
		</antcallback>
		
		<if>
			<not><equals arg1="${resource.file}" arg2="$${resource.file}" /></not>
			<then>
				<!-- extract file since the file translation was defined -->
				<antcall target="extractFileResource">
					<param name="resource.base" value="${resource.base}" />
				</antcall>
			</then>
			<else>
				<antcall target="extractZipResource">
					<param name="resource.base" value="${resource.base}" />
				</antcall>
			</else>
		</if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Extracts a file static resource
	 *  @param resource.base
	**/
	 -->
	<target name="extractFileResource">
		<antcall target="verifyResourceExists">
			<param name="resource.name" value="${resource.name}" />
			<param name="resource.base" value="${resource.base}" />
		</antcall>
		
		<copy file="${staticresources.path}/${resource.name}" tofile="${resources.path}/${resource.file}" overwrite="true" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  compresses a file static resource
	 *  @param resource.base
	**/
	 -->
	<target name="compressFileResource">
		<antcall target="verifyResourceFileExists">
			<param name="resource.file" value="${resource.file}" />
			<param name="resource.base" value="${resource.base}" />
		</antcall>
		
		<copy tofile="${staticresources.path}/${resource.name}" file="${resources.path}/${resource.file}" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Extracts a zip static resource
	 *  @param resource.base
	**/
	 -->
	<target name="extractZipResource">
		<antcall target="verifyResourceExists">
			<param name="resource.name" value="${resource.name}" />
			<param name="resource.base" value="${resource.base}" />
		</antcall>
		
		<antcallback target="getZipResource" return="resource.name,resource.zip" />
		
		<delete dir="${resources.path}/${resource.zip}" />
		<unzip src="${staticresources.path}/${resource.name}" dest="${resources.path}/${resource.zip}" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  compresses a zip static resource
	 *  @param resource.base
	**/
	 -->
	<target name="compressZipResource">
		<antcall target="verifyResourceZipExists">
			<param name="resource.zip" value="${resource.zip}" />
			<param name="resource.base" value="${resource.base}" />
		</antcall>
		
		<delete file="${staticresources.path}/${resource.name}" />
		<zip destfile="${staticresources.path}/${resource.name}">
			<fileset dir="${resources.path}/${resource.zip}/" includes="**/*.*" />
		</zip>
	</target>
	
	
	
	
	<!--
	/**
	 * Determines a delimited list of all the resource lists
	 **/
	-->
	<target name="getResourceLists">
		<propertyselector property="resourceLists"
			delimiter=","
			match="(\w+)[.]fileResources"
			select="\1"
			casesensitive="false"
		/>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Determines the resources for each of the lists
	**/
	 -->
	<target name="listResources">
		<propertycopy name="fileResources" from="${listName}.fileResources" />
		<propertycopy name="zipResources" from="${listName}.zipResources" />
		
		<property name="allResources" value="${fileResources};${zipResources}" />
		<echo>${listName}
File Resources: ${fileResources}
Zip Resources: ${zipResources}</echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Extracts all resources within the list of resources sent
	 *  @param allFileResources
	 *  @param allZipResources
	**/
	 -->
	<target name="extractAllResources">
		<!-- default list of all resources to compile, if not already provided -->
		<property name="allFileResources" value="IconTheme,JQuery_IC_CSS,LVMHSmallBackGound,VuittonDegrade,cloudtunes,cloudtunes_offline,cloudtunes_smartstore,jQuery_CSS,jQuery_JS,jQuery_Multiselect_CSS,jQuery_Multiselect_JS,jQuery_UI_JS,jQuery_scrollTo_JS" />
		<property name="allZipResources" value="Calendar,Cordova,IPadApp,IPadJQueryUI,IPadSlides,IPhoneApp,IconImages,JQuery_120,JQuery_130,STR_LV_Images,STR_LouisVuitton,SiteSamples,cloudtunes_jQuery,flower,jszip,underscore_1_5_1_js" />
		
		<foreach list="${allFileResources}"
			target="extractFileResource"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
		
		<foreach list="${allZipResources}"
			target="extractZipResource"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Compresses all resources within a list of resources sent
	 *  @param allFileResources
	 *  @param allZipResources
	**/
	 -->
	<target name="compressAllResources">
		<!-- default list of all resources to compile, if not already provided -->
		<property name="allFileResources" value="IconTheme,JQuery_IC_CSS,LVMHSmallBackGound,VuittonDegrade,cloudtunes,cloudtunes_offline,cloudtunes_smartstore,jQuery_CSS,jQuery_JS,jQuery_Multiselect_CSS,jQuery_Multiselect_JS,jQuery_UI_JS,jQuery_scrollTo_JS" />
		<property name="allZipResources" value="Calendar,Cordova,IPadApp,IPadJQueryUI,IPadSlides,IPhoneApp,IconImages,JQuery_120,JQuery_130,STR_LV_Images,STR_LouisVuitton,SiteSamples,cloudtunes_jQuery,flower,jszip,underscore_1_5_1_js" />
		
		<foreach list="${allFileResources}"
			target="compressFileResource"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
		
		<foreach list="${allZipResources}"
			target="compressZipResource"
			param="resource.base"
			delimiter=","
			trim="true"
			parallel="false"
		/>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Translates a resource base to a resource name and either a resource file name or resource zip name
	 *  @param resource.base
	 *  @return resource.name
	 *  @return resource.file - if the resource base has a file associated
	 *  @return resource.zip - if the resource base has a zip associated
	**/
	 -->
	<target name="findResourceTranslation">
		<trycatch>
			<try>
				<antcallback target="getFileResource" return="resource.name,resource.file" />
			</try>
			<catch></catch>
		</trycatch>
		<trycatch>
			<try>
				<antcallback target="getZipResource" return="resource.name,resource.zip" />
			</try>
			<catch></catch>
		</trycatch>
		
		<if>
			<equals arg1="${resource.name}" arg2="$${resource.name}" />
			<then>
				<mm:Halt><![CDATA[

ERROR OCCURRED, unable to find resource mapping for resource in build.properties: ${resource.base}

Please run the following to add a translation
for ${resource.base}

ant addResourceTranslation


				]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Verifies that a resource exists and fails if it is not found.
	 *  <p>Can be used by both files and zips</p>
	 *  @param resource.name
	 *  @param resource.base
	**/
	-->
	<target name="verifyResourceExists">
		<var name="resource.path" unset="true" />
		<var name="resource.exists" unset="true" />
		<property name="resource.path" value="${staticresources.path}/${resource.name}" />
		<available file="${resource.path}" type="file" property="resource.exists" />
		<if><equals arg1="${resource.exists}" arg2="$${resource.exists}" /><then>
			<echo>Unable to find resource: ${resource.path} ${line.separator}Check definition for ${resource.base}.resource in build.properties.</echo>
			<mm:Halt><![CDATA[Unable to find resource: ${resource.path} ${line.separator}Check definition for ${resource.base}.resource in build.properties.]]></mm:Halt>
		</then></if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  
	 *  Verifies that a file resource exists, and fails if it is not found
	 *  @param resource.file
	 *  @param resource.base
	 *  
	**/
	-->
	<target name="verifyResourceFileExists">
		<var name="resource.path" unset="true" />
		<var name="resource.exists" unset="true" />
		<property name="resource.path" value="${resources.path}/${resource.file}" />
		<available file="${resource.path}" type="file" property="resource.exists" />
		<if><equals arg1="${resource.exists}" arg2="$${resource.exists}" /><then>
			<echo>Unable to find file resource: ${resource.path} ${line.separator}Check definition for ${resource.base}.file in build.properties.</echo>
			<mm:Halt><![CDATA[Unable to find file resource: ${resource.path} ${line.separator}Check definition for ${resource.base}.file in build.properties.]]></mm:Halt>
		</then></if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  
	 *  Verifies that a zip resource exists, and fails if it is not found
	 *  @param resource.file
	 *  @param resource.base
	 *  
	**/
	-->
	<target name="verifyResourceZipExists">
		<var name="resource.path" unset="true" />
		<var name="resource.exists" unset="true" />
		<property name="resource.path" value="${resources.path}/${resource.zip}" />
		<available file="${resource.path}" type="dir" property="resource.exists" />
		<if><equals arg1="${resource.exists}" arg2="$${resource.exists}" /><then>
			<mm:Halt><![CDATA[Unable to find zip resource: ${resource.path} ${line.separator}Check definition for ${resource.base}.zip in build.properties]]></mm:Halt>
		</then></if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Verifies if a deploy exists, or creates one if one does not.
	**/
	 -->
	<target name="verifyDeployExists">
		<mkdir dir="${deploy.path}" />
		
		<available file="${deploy.package.path}" type="file" property="deploy.package.exists" />
		<if>
			<and>
				<equals arg1="${deploy.package.exists}" arg2="$${deploy.package.exists}" />
			</and>
			<then>
				<!-- make the package -->
				<echo>making the file</echo>
				<mm:SFDC_NewPackage version='${SFDC_VERSION}' target='${deploy.package.path}' />
			</then>
			<else>
				<echo>file exists</echo>
			</else>
		</if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Creates a comma separated list of files based on some matching string
	 *  @param source.dir
	 *  @param file.match
	 *  @return file.list
	**/
	-->
	<target name="getDirectoryFiles">
		<var name="file.list1" unset="true" />
		<var name="file.list2" unset="true" />
		<var name="file.list" unset="true" />
		<property name="file.exclude" value="" />
		
		<fileset dir="${source.dir}" id="source.dirset" >
			<include name="${file.match}" />
			<exclude name="${file.exclude}" />
		</fileset>
		<property name="file.list1" refid="source.dirset" />
		<propertyregex property="file.list2"
			input="${file.list1}"
			regexp="\s*;\s*"
			replace=","
			global="true"
		/>
		
		<if>
			<not>
			<or>
				<equals arg1="${remove.extension}" arg2="" />
				<equals arg1="${remove.extension}" arg2="$${remove.extension}" />
			</or>
			</not>
			<then>
				<propertyregex property="file.list"
					input="${file.list2}"
					regexp="${remove.extension}"
					replace=""
					global="true"
					casesensitive="false"
				/>
			</then>
			<else>
				<property name="file.list" value="${file.list2}" />
			</else>
		</if>
		
		<property name="file.list" value="" />
		
		<!--
		<echo>${file.list}</echo>
		-->
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Removes an extension from a file name
	**/
	 -->
	<target name="removeExtension">
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Adds a resource to the deployment
	 *  @param resource.base
	**/
	 -->
	<target name="addResourceToDeploy">
		<trycatch>
			<try>
				<antcallback target="getZipResource" return="resource.name,resource.zip" />
			</try>
			<catch>
				<antcallback target="getFileResource" return="resource.name,resource.zip" />
			</catch>
		</trycatch>
		
		<antcall target="verifyDeployExists" />
		
		<mm:SFDC_ConvertFolderToMetadata folderName="${staticresources.dir}" targetProperty="deploy.staticresource.type" />
		<!--
		<echo>${staticresources.dir} ${deploy.staticresource.type}</echo>
		<mm:Halt />
		-->
		
		<mm:SFDC_AddPackageMember sourceFile="${deploy.package.path}" targetFile="${deploy.package.path}"
			metadataType="${deploy.staticresource.type}" member="${resource.base}" />
			
		<property name="deploy.staticresource.path" value="${deploy.path}/${staticresources.dir}" />
		
		<mkdir dir="${deploy.staticresource.path}" />
		<copy file="${staticresources.path}/${resource.name}" tofile="${deploy.staticresource.path}/${resource.name}" />
		<copy file="${staticresources.path}/${resource.name}${meta_suffix}" tofile="${deploy.staticresource.path}/${resource.name}${meta_suffix}" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Change the property value in a specific property file
	 *  @visibility INTERNAL
	 *  @param propertyFile.path (String) - the path of the property file to change
	 *  @param propertyName (String) - the name of the property
	 *  @param propertyValue (String) - the new value of the property
	 **/
	-->
	<target name="changePropertyFileValue">
		<fail unless="propertyFile.path">propertyFile.path must be set</fail>
		<fail unless="property.name">property.name must be set</fail>
		<fail unless="property.value">property.value must be set</fail>
		
		<replaceregexp encoding="UTF-8" file="${propertyFile.path}"
			match="^([ \t]*)${property.name}\s*=[^\n]*"
			replace="\1${property.name}=${property.value}"
			flags="img"
		/>
		
		<var name="propertyFile.path" unset="true" />
		<var name="property.name" unset="true" />
		<var name="property.value" unset="true" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Creates a list of the static resources in a fileList
	 *  @param fileList.path
	 *  @return staticresource.list
	**/
	 -->
	<target name="getFileListResources">
		<var name="staticresource.list1" unset="true" />
		<var name="staticresource.list2" unset="true" />
		<var name="staticresource.list3" unset="true" />
		<var name="staticresource.list4" unset="true" />
		<var name="staticresource.list5" unset="true" />
		<var name="staticresource.list" unset="true" />
		
		<loadfile srcfile="${fileList.path}" property="staticresource.list1">
			<filterchain>
				<filterReader classname="org.apache.tools.ant.filters.LineContainsRegExp">
					<param type="regexp" value="staticresources/" />
					<param type="casesensitive" value="false" />
				</filterReader>
			</filterchain>
		</loadfile>
		
		<if>
			<equals arg1="${staticresource.list1}" arg2="$${staticresource.list1}" />
			<then>
				<property name="staticresource.list" value="" />
			</then>
			<else>
				<propertyregex property="staticresource.list2"
					input="${staticresource.list1}"
					regexp="staticresources/"
					replace="†"
					global="true" casesensitive="false"
				/>
				<propertyregex property="staticresource.list3"
					input="${staticresource.list2}"
					regexp="(^|\n)[^\n†]*†"
					replace=""
					global="true" casesensitive="false"
				/>
				<propertyregex property="staticresource.list4"
					input="${staticresource.list3}"
					regexp="[.]resource\s*"
					replace=","
					global="true" casesensitive="false"
				/>
				
				<propertyregex property="staticresource.list5"
					input="${staticresource.list4}"
					regexp="\s*,$"
					replace=""
					global="true" casesensitive="false"
				/>
				<!--
				<echo>1-${staticresource.list1}</echo>
				<echo>2-${staticresource.list2}</echo>
				<echo>3-${staticresource.list3}</echo>
				<echo>4-${staticresource.list4}</echo>
				<echo>5-${staticresource.list5}</echo>
				-->
				
				<if>
					<equals arg1="${staticresource.list5}" arg2="$${staticresource.list5}" />
					<then>
						<mm:Halt><![CDATA[${n}${n}Static resource: ${staticresource.list1} is not properly formatted or does not have an extension]]></mm:Halt>
					</then>
				</if>
				
				<property name="staticresource.list" value="${staticresource.list5}" />
			</else>
		</if>
		
		<!--
		<echo>
orig[${fileList.path}]
1[${staticresource.list1}]
2[${staticresource.list2}]
3[${staticresource.list3}]
4[${staticresource.list4}]
5[${staticresource.list5}]
list[${staticresource.list}]</echo>
		-->
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Validates that deployment credentials are provided.
	**/
	 -->
	<target name="validateDeployCredentials">
		<if>
			<or>
				<equals arg1="${deploy.username}" arg2="" />
				<equals arg1="${deploy.username}" arg2="$${deploy.username}" />
			</or>
			<then>
				<mm:Halt><![CDATA[deploy credentials not defined within build.properties.${n}
${n}
Expected:${n}
deploy.username${n}
deploy.password${n}
deploy.serverurl${n}
deploy.maxPoll]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Validates that retreival credentials are provided.
	**/
	 -->
	<target name="validateRetrieveCredentials">
		<if>
			<or>
				<equals arg1="${retrieve.username}" arg2="" />
				<equals arg1="${retrieve.username}" arg2="$${retrieve.username}" />
			</or>
			<then>
				<mm:Halt><![CDATA[deploy credentials not defined within build.properties.${n}
${n}
Expected:${n}
deploy.username${n}
deploy.password${n}
deploy.serverurl${n}
deploy.maxPoll]]></mm:Halt>
			</then>
		</if>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Validates that retreival credentials are provided.
	**/
	 -->
    <target name="testCredentials" description="Tests specific credentials">
    	<input
			message="username"
			addproperty="test.username"
		/>
		
		<input
			message="password"
			addproperty="test.password"
		/>
		
		<input
			message="serverURL (https://test.salesforce.com or https://login.salesforce.com)"
			addproperty="test.serverurl"
		/>
		
		<echo>
&lt;sf:describeMetadata username="${test.username}" password="${test.password}" serverurl="${test.serverurl}" /&gt;
</echo>
		<sf:describeMetadata username="${test.username}" password="${test.password}" serverurl="${test.serverurl}" />
    </target>
    
    
    
    <!--
    Provides a Heap warning message
    typically used when doing large refreshes.
    -->
    <target name="heapWarning">
    	<echo><![CDATA[

Note: if you get a JavaHeapSpace error,
you need to extend the amount of memory available to ant.

This is accomplished by setting the shell property JAVA_OPTS
to the amount of memory. Such as:
(-Xmx1G sets the amount to 1 Gb of memory, -Xmx1024m sets to 1024 Mb)

ex mac:
export ANT_OPTS=-Xmx1G 

ex windows:
set ANT_OPTS=-Xmx1G
]]></echo>
    </target>
	
	
	
	
	
	<!-- 
	/**
	 *  Asks the user which fileList to use
	 *  @return
	**/
	 -->
	<target name="requestFileList">
		<antcallback target="getDirectoryFiles" return="file.list">
			<param name="source.dir" value="${packageLists.path}" />
			<param name="file.match" value="*.txt" />
			<param name="remove.extension" value="[.]txt" />
		</antcallback>
		
		<echo>Which file list should we use?
		
${file.list}</echo>
		<input addproperty="fileList" validargs="${file.list}" defaultvalue="${defaultList}" />
		<var name="defaultList" unset="true" />
		
		<property name="fileList.path" value="${packageLists.path}/${fileList}.txt" />
		<available file="${fileList.path}" type="file" property="fileList.exists" />
		<fail unless="fileList.exists">Could not find file list.</fail>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Creates a package list
	 *  @param includePattern (String default="**/*") - pattern to specify the files to include
	 *  @param excludePattern (String default="") - pattern to specify the files not to include
	 *  @param packageList.path (String) - path to the packageList to create
	**/
	 -->
	<target name="makePackageList">
		<property name="includePattern" value="**/*" />
		<property name="excludePattern" value="" />
		
		<!-- reset the file -->
		<touch file="${packageList.path}" />
		
		<if>
			<or>
				<contains string="${includePattern}" substring="aura/" casesensitive="false" />
			</or>
			<then>
				<echo>Looking for aura components</echo>
				<propertyregex property="includePattern"
					input="${includePattern}"
					regexp="aura/"
					replace=""
					override="true"
					/>
				<foreach target="makePackageListAll2_internal"
					param="filePath"
				>
					<path>
					<dirset dir="${src.path}/aura" casesensitive="no">
						<include name="${includePattern}" />
						<exclude name="${excludePattern}" />
						<exclude name="**/*-meta.xml" />
					</dirset>
					</path>
				</foreach>
			</then>
			<else>
				<foreach target="makePackageListAll2_internal"
					param="filePath"
				>
					<fileset dir="${src.path}" casesensitive="no">
						<include name="${includePattern}" />
						<exclude name="${excludePattern}" />
						<exclude name="**/*-meta.xml" />
					</fileset>
				</foreach>
			</else>
		</if>
	</target>
	
	<target name="makePackageListAll2_internal">
		<propertyregex property="filePath.clean"
			input="${filePath}"
			regexp="/?src/(.+)"
			select="\1"
		/>
		<echo>${filePath.clean}</echo>
		<echo file="${packageList.path}" append="true">${filePath.clean}${line.separator}</echo>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Determines a CSV list of directories
	 *  @param base.dir (String) the path to the directory to be looked within
	 *  @return dir.list (String) CSV list of directories
	**/
	 -->
	<target name="getDirList">
		<var name="dir.list" unset="true" />
		<var name="dir.list1" unset="true" />
		<property name="dir.filter" value="*" />
		
		<dirset dir="${base.dir}" id="src.dirset" >
			<include name="${dir.filter}" />
		</dirset>
		<property name="dir.list1" refid="src.dirset" />
		
		<if>
			<or>
			<equals arg1="${dir.list1}" arg2="$${dir.list1}" />
			<equals arg1="${dir.list1}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[no folders are version controlled in in ${src.path}]]></mm:Halt>
			</then>
		</if>
		
		<propertyregex property="dir.list"
			input="${dir.list1}"
			regexp="\s*;\s*"
			replace=","
			global="true"
		/>
		<property name="dir.list" value="${dir.list1}" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Determines a csv list of files under a directory
	 *  @param base.dir (String) path to the base directory to search
	 *  @return dir.list (String) CSV list of the files under the directory
	**/
	 -->
	<target name="getFileList">
		<property name="includePattern" value="*" />
		<property name="excludePattern" value="" />
		
		<var name="file.list" unset="true" />
		<var name="file.list1" unset="true" />
		
		<fileset dir="${base.dir}" id="fileList.set">
			<include name="${includePattern}" />
			<exclude name="${excludePattern}" />
			<exclude name="**/*-meta.xml" />
		</fileset>
		<property name="file.list1" refid="fileList.set" />
		
		<if>
			<or>
			<equals arg1="${file.list1}" arg2="$${file.list1}" />
			<equals arg1="${file.list1}" arg2="" />
			</or>
			<then>
				<mm:Halt msg="There doesn't seem to be any files in ${src.path}/${base.dir}" />
			</then>
		</if>
		
		<propertyregex property="file.list"
			input="${file.list1}"
			regexp="\s*;\s*"
			replace=","
			global="true"
		/>
		<property name="file.list" value="${file.list1}" />
		
		<property name="file.list" value="" />
		
	</target>
	
	
	
	
	<!--
	/**
	 *  Filters out the contents in the tmp file inline
	 *  <p>Assumes that either filterTmpInquiry has already been called, or filterSet
	 *  property has already been set</p>
	 *  @param filterTarget (String) - the path to file to be filtered inline
	 *  @param filterSet (String) - the filter that limits the lines to those that include it
	 **/
	-->
	<target name="filterFile">
		<echo>lineFilter:${lineFilter}</echo>
		<echo>filterTarget=${filterTarget}</echo>
		
		<var name="filterSet" unset="true" />
		<trycatch>
			<try>
				<loadfile srcfile="${filterTarget}" property="filterSet">
					<filterchain>
						<filterReader classname="org.apache.tools.ant.filters.LineContainsRegExp">
							<param type="regexp" value="${lineFilter}" />
							<param type="casesensitive" value="false" />
						</filterReader>
					</filterchain>
				</loadfile>
			</try>
			<catch>
				<mm:Halt><![CDATA[An invalid pattern was used. Please try again]]></mm:Halt>
			</catch>
		</trycatch>
		
		<if>
			<equals arg1="${filterSet}" arg2="$${filterSet}" />
			<then>
				<echo>No matches found for [${lineFilter}]</echo>
				<echo file="${filterTarget}"></echo>
			</then>
			<else>
				<echo file="${filterTarget}">${filterSet}</echo>
			</else>
		</if>
		<var name="filterTarget" unset="true" />
		<var name="lineFilter" unset="true" />
		
		<!--
		<echo>${filterSet}</echo>
		-->
	</target>
	
	
	
	
	<!--
	/**
	 *  Determines the line filter.
	 *  <p>This must be called before calling filterTmp, but by separating it out,
	 *  allows the filterTmp to be called separately without asking the end user</p>
	 *  @param filterTarget (String) - the path to file to be filtered inline
	 *  @see filterFile
	 **/
	-->
	<target name="filterFileInquiry">
		<echo><![CDATA[
Which filters should we apply
(Enter blank for all values)

Ex:
* 'LNE_' will find all that start with LNE_ (like LNE_Account)

* '.*__c' will find all custom classes

(Regex and not SOQL wildcards are used)
]]></echo>
		<var name="lineFilter" unset="true" />
		<input
			addproperty="lineFilter"
		/>
		
		<antcall target="filterFile" inheritall="true" />
	</target>
	
	
	
	
	<!--
	/**
	 *  Sorts a specific file inline
	 *  @param sortTarget (String) - path to file to be sorted
	 **/
	-->
	<target name="sortFile">
		<concat destfile="${tmp.sorted.path}">
			<union>
				<sort>
					<tokens>
						<file file="${sortTarget}" />
						<linetokenizer includedelims="true" />
					</tokens>
				</sort>
			</union>
		</concat>
		<move file="${tmp.sorted.path}" tofile="${sortTarget}" />
		<var name="sortTarget" unset="true" />
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Determines the code home
	**/
	 -->
	<target name="checkCodeHome">
		<if>
			<or>
				<equals arg1="${codeHome}" arg2="$${codeHome}" />
				<equals arg1="${codeHome}" arg2="" />
			</or>
			<then>
				<echo>
codeHome was not defined in build.properties.

Please set this value to avoid being prompted for this again.

</echo>

				<echo>
What is the location of the local git repository
(this is used in determining the commits and changes)
</echo>
				<var name="codeHome" unset="true" />
				<input addproperty="codeHome" />
			</then>
		</if>
		
		<available file="${codeHome}" type="dir" property="codeHome.found" />
		<fail unless="codeHome.found">CodeHome [${codeHome}] cound not be found</fail>
	</target>
	
	
	
	
	<!-- 
	/**
	 *  Asks for a revision range.
	**/
	 -->
	<target name="getRevisionRange">
<echo>

What is the revision we should start from
(Default is 10th commit from HEAD, but can be a specific SHA)
(not including this revision)
</echo>
		<input addproperty="revisionStart" defaultvalue="HEAD~10" />
		
		<echo>What is the revision we should continue to
(not including this revision)
</echo>
		<input addproperty="revisionEnd" defaultvalue="HEAD" />
		
		<if>
			<or>
				<equals arg1="${revisionStart}" arg2="$${revisionStart}" />
				<equals arg1="${revisionStart}" arg2="" />
			</or>
			<then>
				<mm:Halt><![CDATA[${abort.user}]]></mm:Halt>
			</then>
		</if>
		
		<if>
			<or>
				<equals arg1="${revisionEnd}" arg2="$${revisionEnd}" />
				<equals arg1="${revisionEnd}" arg2="" />
			</or>
			<then>
				<var name="revisionEnd" unset="true" />
				<property name="revisionEnd" value="HEAD" />
			</then>
		</if>
	</target>
</project>
